import{_ as e,o as a,c as n,R as p}from"./chunks/framework.4hIqoSk1.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"engine/package/01.md","filePath":"engine/package/01.md","lastUpdated":1733279472000}'),l={name:"engine/package/01.md"},i=p(`<p><a href="https://juejin.cn/post/6844903870578032647" target="_blank" rel="noreferrer">【npm 知识汇总】</a><a href="https://juejin.cn/post/6844904022080667661" target="_blank" rel="noreferrer">【npm包管理机制 抖音安全】</a></p><h2 id="npm-是什么" tabindex="-1">npm 是什么？ <a class="header-anchor" href="#npm-是什么" aria-label="Permalink to &quot;npm 是什么？&quot;">​</a></h2><p>NPM(Node Package Manager) 是 Node.js 提供的一个包管理器, 可以使用 NPM 来安装 node.js 包</p><h2 id="npm-不同版本之间的区别" tabindex="-1">npm 不同版本之间的区别？ <a class="header-anchor" href="#npm-不同版本之间的区别" aria-label="Permalink to &quot;npm 不同版本之间的区别？&quot;">​</a></h2><h2 id="pnpm、yarn、npm-的对比" tabindex="-1">pnpm、yarn、npm 的对比？ <a class="header-anchor" href="#pnpm、yarn、npm-的对比" aria-label="Permalink to &quot;pnpm、yarn、npm 的对比？&quot;">​</a></h2><h2 id="package-json-的作用是什么-如何生成" tabindex="-1">package.json 的作用是什么，如何生成？ <a class="header-anchor" href="#package-json-的作用是什么-如何生成" aria-label="Permalink to &quot;package.json 的作用是什么，如何生成？&quot;">​</a></h2><h2 id="package-json-有哪写常用配置" tabindex="-1">package.json 有哪写常用配置？ <a class="header-anchor" href="#package-json-有哪写常用配置" aria-label="Permalink to &quot;package.json 有哪写常用配置？&quot;">​</a></h2><h2 id="dependencies-的作用" tabindex="-1">dependencies 的作用？ <a class="header-anchor" href="#dependencies-的作用" aria-label="Permalink to &quot;dependencies 的作用？&quot;">​</a></h2><p>项目中的三方依赖，会被构建打包到最终的产物中。</p><h2 id="devdependencies-的作用" tabindex="-1">devDependencies 的作用？ <a class="header-anchor" href="#devdependencies-的作用" aria-label="Permalink to &quot;devDependencies 的作用？&quot;">​</a></h2><p>仅开发环境会使用到，不会被打包到最终的产物中。</p><h2 id="peerdependencies-的作用" tabindex="-1">peerDependencies 的作用？ <a class="header-anchor" href="#peerdependencies-的作用" aria-label="Permalink to &quot;peerDependencies 的作用？&quot;">​</a></h2><p>一般开发插件、库的时候会用到，其中依赖的三方库，一般会放在<code>peerDependencies</code>中. 例如 <code>antd</code>组件库</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;peerDependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;react&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;=16.9.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;react-dom&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&gt;=16.9.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>好处</strong></p><ul><li><p>要求项目拥有 peerDependencies 所指定的环境依赖, 完成子环境要求父环境具有某些依赖包</p></li><li><p>提升项目(插件)依赖</p></li><li><p>减少重复安装依赖</p></li></ul><p>参考链接：<a href="https://www.cnblogs.com/fitzlovecode/p/peerDependencies.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/fitzlovecode/p/peerDependencies.html</a></p><h2 id="package-lock-json-的作用" tabindex="-1">package-lock.json 的作用？ <a class="header-anchor" href="#package-lock-json-的作用" aria-label="Permalink to &quot;package-lock.json 的作用？&quot;">​</a></h2><p>参考链接：<a href="https://www.cnblogs.com/fitzlovecode/p/diff_between_package_and_package-lock.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/fitzlovecode/p/diff_between_package_and_package-lock.html</a></p><h2 id="npx-的作用" tabindex="-1">npx 的作用？ <a class="header-anchor" href="#npx-的作用" aria-label="Permalink to &quot;npx 的作用？&quot;">​</a></h2><blockquote><p>npm 从 5.2 版开始，增加了 npx 命令.<br> 2 个核心功能</p></blockquote><ol><li><p>调用项目安装的模块（默认调用必须在 script 字段中或者项目脚本中）例如： <code>$ node-modules/.bin/mocha --version</code> 现在只需要<code>$ npx mocha --version</code> 即可</p></li><li><p>避免全局安装模块 (如果没有该模块，就临时下载，使用后会自动删除)<br> 详细查看 <a href="https://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noreferrer">阮一峰 npx 文章</a></p></li></ol><p>参考链接：<a href="https://www.cnblogs.com/fitzlovecode/p/learn_npx.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/fitzlovecode/p/learn_npx.html</a></p><h2 id="npm-install-的机制" tabindex="-1">npm install 的机制？ <a class="header-anchor" href="#npm-install-的机制" aria-label="Permalink to &quot;npm install 的机制？&quot;">​</a></h2><p><code>第一步：首先会去查找npm的配置信息。</code><br> npm install 执行之后, 首先会检查和获取 npm 的配置,这里的优先级为:</p><blockquote><p>项目级的.npmrc 文件 &gt; 用户级的 .npmrc 文件 &gt; 全局级的 .npmrc &gt; npm 内置的 .npmrc 文件</p></blockquote><p>npm 提供了几个 npm config 指令来进行用户级和全局级配置 <code>npm config set &lt;key&gt; &lt;value&gt; [-g|--global]</code> 使用-g|--global 标志修改或新增全局级配置，不使用的话修改或者新增用户级配置（相应级别的.npmrc 文件会更新）。</p><p><code>第二步：获取完配置文件之后，就会构建依赖树。</code></p><ul><li>无 lock 文件： <ul><li>从 npm 远程仓库获取包信息。</li><li>根据 package.json 构建依赖树，构建过程： <ul><li>构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录。</li><li>当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的 node_modules 下放置该模块。</li><li>注意这一步只是确定逻辑上的依赖树，并非真正的安装，后面会根据这个依赖结构去下载或拿到缓存中的依赖包</li></ul></li></ul></li><li>有 lock 文件： <ul><li>检查 package.json 中的依赖版本是否和 package-lock.json 中的依赖有冲突。会按照<code>semver(语义化)</code>版本规范检测。 <ul><li>如果一致，直接跳过获取包信息、构建依赖树过程，开始在缓存中查找包信息。</li><li>如果不一致，经测试。。是在有<code>^</code>符号的前提下 <ul><li>如果使用<code>^x.x.x</code>大版本不同的话按照 package.json 版本安装。例如：lock 文件<code>^3.1.0</code>，package.json 是 <code>^2.1.0</code> 则会安装 2 这个大版本下的最新小版本。</li><li>如果大版本相同的话，谁的小版本大按照谁的安装。</li></ul></li></ul></li></ul></li></ul><p><code>第三步：在有了依赖树之后，就可以根据依赖树下载完整的依赖资源。</code></p><blockquote><p>在下载之前，会先检查下是否有缓存资源，如果存在缓存资源的话，那么直接将缓存资源解压到 node_modules 中。如果没有缓存资源，那么会先将 npm 远程仓库中的包下载至本地，然后会进行包的完整性校验，校验通过后将其添加的缓存中并解压到 node_modules 中。</p></blockquote><p><code>第四步：会生成 package-lock.json 文件。</code><br> 整体流程图： <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c87b3d0879fc411fbbde141261c0720d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp?" alt=""></p><h2 id="npm-run-xxx-的原理" tabindex="-1">npm run xxx 的原理？ <a class="header-anchor" href="#npm-run-xxx-的原理" aria-label="Permalink to &quot;npm run xxx 的原理？&quot;">​</a></h2><p><a href="https://juejin.cn/post/7078924628525056007" target="_blank" rel="noreferrer">https://juejin.cn/post/7078924628525056007</a></p><p>总结</p><ul><li>运行 npm run xxx 的时候，npm 会先在当前目录的 node_modules/.bin 查找要执行的程序，如果找到则运行；</li><li>没有找到则从全局的 node_modules/.bin 中查找，npm i -g xxx 就是安装到到全局目录；</li><li>如果全局目录还是没找到，那么就从 path 环境变量中查找有没有其他同名的可执行程序。</li></ul><h2 id="npm-link-的作用" tabindex="-1">npm link 的作用？ <a class="header-anchor" href="#npm-link-的作用" aria-label="Permalink to &quot;npm link 的作用？&quot;">​</a></h2>`,37),o=[i];function s(t,r,c,d,h,m){return a(),n("div",null,o)}const g=e(l,[["render",s]]);export{u as __pageData,g as default};
