import{_ as p,D as h,o as t,c as k,k as s,I as n,w as l,a as i,R as e}from"./chunks/framework.4hIqoSk1.js";const r="/larry-book-vite/assets/observe.m_FPOxMz.png",gs=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frame/vue2/02.md","filePath":"frame/vue2/02.md","lastUpdated":1733279472000}'),d={name:"frame/vue2/02.md"},c=e("",7),E=s("code",null,"div1",-1),o=s("code",null,"{ name: 按钮1 }",-1),g=e("",2),y=s("code",null,"div1",-1),u=s("code",null,"{ name: 按钮1 }",-1),b=e("",2),F=s("code",null,"div1",-1),m=s("code",null,"{ name: 按钮1, age: 3}",-1),A=e("",2),D=s("code",null,"div2",-1),C=s("code",null,"{ name: liu }",-1),_=s("blockquote",null,[s("p",null,[s("strong",null,"解析："),i(" 上边也是解释过了，由于"),s("code",null,"Object.defineProperty"),i(" 无法劫持到新属性，所以无法触发响应式，没有触发渲染。")])],-1),v=s("p",null,[s("strong",null,[i("5. （重置页面）点击"),s("code",null,"电钮 5"),i(", "),s("code",null,"div2"),i(" 显示什么，为什么？")])],-1),B=s("code",null,"div2",-1),f=s("code",null,"{ name: 按钮5, age: 5}",-1),q=s("blockquote",null,[s("p",null,[s("strong",null,"解析："),i(" 参考第三题")])],-1),x=s("p",null,[s("strong",null,[i("6. （重置页面）先点击"),s("code",null,"按钮 4"),i("，然后再点击"),s("code",null,"按钮 6"),i("，"),s("code",null,"div2"),i(" 显示什么，为什么？")])],-1),T=s("code",null,"div2",-1),V=s("code",null,"{ name: 按钮6, age: 4}",-1),P=e("",2),w=s("code",null,"div2",-1),S=s("code",null,"{ name: 按钮5, age: 5}",-1),O=e("",14),j=e("",2),I=e("",12),M=e("",1),$=s("strong",null,"合并成数组形式",-1),N=s("strong",null,"去重",-1),R=s("li",null,[s("p",null,[s("code",null,"watch"),i(" 在父子选项同时存在的情况下，会"),s("strong",null,"合并成数组形式"),i("，"),s("strong",null,"不去重"),i("。")])],-1),W=e("",3),L=e("",4),U=e("",15),G=s("p",null,[i("Vue 首先在初始化后，会通过"),s("code",null,"Object.defineProperty"),i(", 对数据进行劫持，从而能够拦截到我们访问"),s("code",null,"get"),i("和赋值"),s("code",null,"set"),i("操作，针对于数组的话，Vue 采用的是重写数组的 7 个改变自身的原型方法，从而达到劫持效果。整个过程是一个递归过程，新添加的属性是不支持响应式的，Vue 提供了 "),s("code",null,"$set"),i(" 和 "),s("code",null,"$delete"),i("来处理。")],-1),J=e("",1),K=e("",7),z=e("",2),H=s("p",null,[s("code",null,"Observer"),i("的作用，就是把一个数据 转换为"),s("strong",null,"响应式数据"),i("。构造函数内部会调用 "),s("code",null,"defineReactive"),i("方法进行响应式处理，其核心的"),s("code",null,"Object.definePropperty"),i(" 就在这里。")],-1),Y=e("",3),Q=e("",3),X=e("",11),Z=e("",12),ss=e("",8),is=e("",1),as=e("",22),ns=s("code",null,"AST",-1),ls=e("",5),es=s("ul",null,[s("li",null,"通过递归的方式标记所有的元素节点"),s("li",null,"如果节点本身是静态节点，但是存在非静态的子节点，则将节点修改为非静态节点")],-1),ps=e("",57);function hs(ts,ks,rs,ds,cs,Es){const a=h("font");return t(),k("div",null,[c,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("答案")]),_:1})]),i("： "),E,i(" 显示 "),o]),g,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("答案")]),_:1})]),i("："),y,i(" 显示 "),u]),b,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("答案")]),_:1})]),i("： "),F,i(" 显示 "),m]),A,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("答案")]),_:1})]),i("："),D,i(" 显示 "),C]),_,v,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("答案")]),_:1})]),i("："),B,i(" 显示 "),f]),q,x,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("答案")]),_:1})]),i("："),T,i(" 显示 "),V]),P,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("答案")]),_:1})]),i("："),w,i(" 显示 "),S]),O,s("p",null,[i("这个过程主要有两件事："),s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("初始化(选项合并、响应式处理)")]),_:1})]),i(" 和 "),s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("建立更新机制")]),_:1})])]),s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("1. 初始化")]),_:1})])]),j,n(a,{color:"red"},{default:l(()=>[i("接下来这个 可说可不说。。。")]),_:1}),s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("2. 建立更新机制")]),_:1})])]),I,s("ul",null,[M,s("li",null,[s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("生命周期")]),_:1})]),i(" 在父子选项同时存在的情况下，会"),$,i("，且"),N,i("。")])]),R]),W,n(a,{color:"red"},{default:l(()=>[i("this.$data 和 this.\\_data`的关系")]),_:1}),L,n(a,{color:"red"},{default:l(()=>[i("其次再来说 `this.xxx` 和 `this_data.xxx` 的关系")]),_:1}),U,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("1. 数据劫持 Object.defineProperty")]),_:1})])]),G,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("2. 依赖收集 dep.depend")]),_:1})])]),J,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("3. 派发更新 dep.notify")]),_:1})])]),K,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("observe() 函数")]),_:1})])]),z,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("Observer 类")]),_:1})])]),H,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("Dep 类")]),_:1})])]),Y,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("Watcher 类")]),_:1})])]),Q,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("不会")]),_:1})]),i("，因为 JS 是单线程的啊。")]),X,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("这里是答案：--------------")]),_:1})])]),Z,s("p",null,[i("处理这个过程就叫做**"),n(a,{color:"red"},{default:l(()=>[i("依赖收集")]),_:1}),i("**, 这里就是用了观察者设计模式。")]),ss,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("首次渲染")]),_:1})])]),is,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("更新渲染")]),_:1})])]),as,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("1. 解析")]),_:1})]),i(" 将组件的 html 模版解析成 AST(抽象语法树) 对象")]),s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("2. 优化")]),_:1})]),i(" 也叫静态标记，遍历 "),ns,i(" 对象，标记每个节点是否为静态节点，以及标记出静态根节点。在 后续更新的过程中 的时候就可以直接跳过这些被标记的节点的比对，从而达到**「优化」**的目的。")]),s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("3. 生成渲染函数")]),_:1})]),i(" 从 AST 生成运行时的渲染函数，即大家说的 render 函数，其实还有一个，就是 staticRenderFns 数组，里面存放了所有的静态节点的渲染函数")]),ls,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("标记静态节点")]),_:1})])]),es,s("p",null,[s("strong",null,[n(a,{color:"blue"},{default:l(()=>[i("标记静态根节点，基于静态节点，进一步标记静态根节点")]),_:1})])]),ps])}const ys=p(d,[["render",hs]]);export{gs as __pageData,ys as default};
