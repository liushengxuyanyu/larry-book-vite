::: tip
这里都是面试常问到的，问题很多都很简单，但回答的是否让面试官满意，完全取决于回答的深度。
:::

## 什么是 JS 的执行上下文？

::: details

**执行上下文**就是当前 `JavaScript` 代码被 **解析** 和 **执行** 时`所在环境的抽象概念`， `JavaScript` 中运行任何的代码都是在**执行上下文**中运行。

> **执行上下文的类型：**

1. **全局执行上下文：** 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：

   1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。
   2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。

2. **函数执行上下文：** 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。

3. **Eval 函数执行上下文：** 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。

:::

## 执行上下文内结构？

::: details
经过编译后，生成对应的执行上下文，其中包括变量环境、词法环境、外部环境、this

变量环境主要是 变量提升、函数的声明，词法环境是 let const 等声明的位置。
:::

## 什么是 JS 调用栈？

::: details
在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。

- 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。

- 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。

- 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。

- 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

:::

## 什么是作用域？

::: details
**作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期.**

作用域分为：

- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。

- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

- 块级作用域 (es6)

:::

## 什么是作用域链？

::: details

作用域链是一种用于查找变量和函数的机制，它是由当前执行环境和其所有父级执行环境的变量对象组成的链式结构。当在一个执行环境中访问变量或函数时，会首先在当前执行环境的变量对象中查找，如果找不到，则会沿着作用域链向上查找，直到找到对应的变量或函数，或者达到最外层的全局对象（如 window）。

作用域链的创建是在函数定义时确定的，它与函数的定义位置有关。当函数被调用时，会创建一个新的执行环境，其中包含一个新的变量对象，并将其添加到作用域链的前端。这样，函数内部就可以访问其所在作用域以及其外部作用域中的变量和函数，形成了一个作用域链。

作用域链并不是由 上下文执行栈或者说作用域 决定的，而是由**<font color="blue">词法作用域</font>**决定的。

:::

## 什么是词法作用域？

::: details
词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

词法作用域 就是 根据代码的位置来决定的。

:::

## 什么闭包？

::: details
在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

使用闭包主要是为了设计私有的方法和变量。

闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。
:::

## 使用闭包应该注意什么？

::: details
如果该闭包会一直使用，那么它可以作为全局变量而存在。（页面关闭后才会被销毁）

但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。（如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。）

:::

## 原型和原型链？

::: details

原型：

JavaScript 的所有对象中都包含了一个 [__proto__] 内部属性，这个属性所对应的就是该对象的原型
JavaScript 的函数对象，除了原型 [__proto__] 之外，还预置了 prototype 属性
当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [__proto__]。

原型链：

当一个对象调用的属性/方法自身不存在时，就会去自己 [__proto__] 关联的前辈 prototype 对象上去找
如果没找到，就会去该 prototype 原型 [__proto__] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”
原型特点：

JavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变
:::

## 谈谈 this 的理解？

::: details
在全局作用域中，this 指向全局对象（在浏览器环境中通常是 window 对象）。

在函数中，this 的值取决于函数的调用方式。

- 如果函数是作为对象的方法调用，this 指向调用该方法的对象。
- 如果函数是作为普通函数调用，this 指向全局对象（非严格模式下）或 undefined（严格模式下）。
- 如果函数是通过 call、apply 或 bind 方法调用，this 指向 call、apply 或 bind 方法的第一个参数所指定的对象。
- 如果函数是作为构造函数调用（使用 new 关键字），this 指向新创建的对象。

在箭头函数中，this 的值是继承自外部作用域的，它不会因为调用方式的改变而改变。
:::

## 谈谈 JS 模块化解决方案？

## 谈谈你对 Event Loop(事件循环)的理解?

## JS 引擎(V8)的工作原理（如何执行一段 JS 代码）？

<style>
  /* 这里是 details 块的样式重写  不要切换黑暗模式 */
  /* .custom-block {
    padding: 0 !important;
    font-size: 16px;
  } */
  .custom-block.details {
    background-color: #fff !important;
    padding: 0 !important;
    font-size: 16px;
  }
  .custom-block.details summary {
    color: #3451b2 !important;
  }
</style>
