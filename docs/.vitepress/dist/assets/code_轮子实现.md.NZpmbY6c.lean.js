import{_ as h,D as k,o as t,c as e,k as s,a as i,I as n,w as l,R as p}from"./chunks/framework.4hIqoSk1.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"code/轮子实现.md","filePath":"code/轮子实现.md","lastUpdated":1733279472000}'),r={name:"code/轮子实现.md"},E=s("p",null,"tip 手写系列：每一个轮子在手写之前，先去了解使用，先会用了，才可能会实现，否则写完也记不住。。",-1),d=s("h2",{id:"实现防抖函数-debounce",tabindex:"-1"},[i("实现防抖函数(debounce)？ "),s("a",{class:"header-anchor",href:"#实现防抖函数-debounce","aria-label":'Permalink to "实现防抖函数(debounce)？"'},"​")],-1),g=s("p",null,[i("防抖函数原理："),s("strong",null,"把触发非常频繁的事件合并成一次去执行 在指定时间内只执行一次回调函数，如果在指定的时间内又触发了该事件，则回调函数的执行时间会基于此刻重新开始计算")],-1),y=p("",3),c=s("code",null,"wait",-1),b=p("",1),F=s("code",null,"delay",-1),u=p("",14),o=p("",1),m=p("",1),A=p("",25),D=p("",31);function C(B,v,f,q,j,_){const a=k("font");return t(),e("div",null,[E,d,g,s("blockquote",null,[s("p",null,[i("防抖动是将多次执行变为 "),s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("最后一次执行")]),_:1})]),i("，节流是将多次执行变成 "),s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("每隔一段时间执行")]),_:1})])])]),y,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("时间戳方式")]),_:1})]),i("： 使用时间戳的节流函数会在第一次触发事件时立即执行，以后每过 "),c,i(" 秒之后才执行一次，并且最后一次触发事件不会被执行。")]),b,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("定时器方式")]),_:1})]),i("：使用定时器的节流函数在第一次触发时不会执行，而是在 "),F,i(" 秒之后才执行，当最后一次停止触发后，还会再执行一次函数")]),u,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("面试最简洁版")]),_:1})]),i(": 至少要区分出来 若属性为值类型，则直接返回；若属性为引用类型，则递归遍历。")]),o,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("面试进阶版")]),_:1})]),i("：解决拷贝循环引用问题、解决拷贝对应原型问题")]),m,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("终极完整版")]),_:1})]),i("：了解下就好，面试没时间写。。")]),A,s("blockquote",null,[s("p",null,[i("LRU 英文全称是 Least Recently Used，英译过来就是 **"),n(a,{color:"red"},{default:l(()=>[i("最近最少使用")]),_:1}),i("**的意思。")])]),D])}const T=h(r,[["render",C]]);export{x as __pageData,T as default};
