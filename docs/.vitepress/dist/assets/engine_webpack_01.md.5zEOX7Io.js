import{_ as p,D as t,o as h,c as o,k as s,I as i,w as e,a,R as n}from"./chunks/framework.4hIqoSk1.js";const ss=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"engine/webpack/01.md","filePath":"engine/webpack/01.md","lastUpdated":1716781226000}'),r={name:"engine/webpack/01.md"},d={id:"基础",tabindex:"-1"},c=s("a",{class:"header-anchor",href:"#基础","aria-label":'Permalink to "<font color="red">================== 基础 =================</font>"'},"​",-1),k=s("h2",{id:"webpack-有哪些配置项-作用是什么",tabindex:"-1"},[a("webpack 有哪些配置项，作用是什么? "),s("a",{class:"header-anchor",href:"#webpack-有哪些配置项-作用是什么","aria-label":'Permalink to "webpack 有哪些配置项，作用是什么?"'},"​")],-1),u={id:"_1-流程类-作用于打包流程某个或若干个环节-直接影响编译打包效果的配置项",tabindex:"-1"},b=s("a",{class:"header-anchor",href:"#_1-流程类-作用于打包流程某个或若干个环节-直接影响编译打包效果的配置项","aria-label":'Permalink to "<font color="blue">1. 流程类：</font> 作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项"'},"​",-1),E=s("ul",null,[s("li",null,[s("code",null,"entry"),a("：用于定义项目入口文件，Webpack 会从这些入口文件开始按图索骥找出所有项目文件；")]),s("li",null,[s("code",null,"context"),a("：项目执行上下文路径；")]),s("li",null,[s("code",null,"output"),a("：配置产物输出路径、名称等；")])],-1),g=s("ul",null,[s("li",null,[s("code",null,"resolve"),a("：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块")]),s("li",null,[s("code",null,"module"),a("：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理")]),s("li",null,[s("code",null,"externals"),a("：用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作")])],-1),m=n("<ul><li><code>optimization</code>：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能</li><li><code>target</code>：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异</li><li><code>mode</code>：编译模式短语，支持 development、production 等值，Webpack 会根据该属性推断默认配置；</li><li><code>plugin</code>：Webpack 插件列表。</li></ul><blockquote><p><strong><code>webpack</code> 首先需要根据输入配置<code>(entry/context)</code> 找到项目入口文件；之后根据按模块处理<code>(module/resolve/externals 等)</code> 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，最后再根据后处理相关配置项<code>(optimization/target 等)</code>合并模块资源、注入运行时依赖、优化产物结构等。</strong></p></blockquote>",2),_={id:"_2-工具类-打包主流程之外-提供更多工程化工具的配置项",tabindex:"-1"},y=s("a",{class:"header-anchor",href:"#_2-工具类-打包主流程之外-提供更多工程化工具的配置项","aria-label":'Permalink to "<font color="blue">2. 工具类：</font> 打包主流程之外，提供更多工程化工具的配置项"'},"​",-1),F=s("ul",null,[s("li",null,[s("code",null,"watch"),a("：用于配置持续监听文件变化，持续构建")]),s("li",null,[s("code",null,"devtool"),a("：用于配置产物 Sourcemap 生成规则")]),s("li",null,[s("code",null,"devServer"),a("：用于配置与 HMR 强相关的开发服务器功能")])],-1),f=s("ul",null,[s("li",null,[s("code",null,"cache"),a("：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果")]),s("li",null,[s("code",null,"performance"),a("：用于配置当产物大小超过阈值时，如何通知开发者")])],-1),C=s("ul",null,[s("li",null,[s("code",null,"stats"),a("：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用")]),s("li",null,[s("code",null,"infrastructureLogging"),a("：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件")])],-1),w=s("h2",{id:"loader-的作用-常用的-loader-有哪些",tabindex:"-1"},[a("loader 的作用，常用的 loader 有哪些？ "),s("a",{class:"header-anchor",href:"#loader-的作用-常用的-loader-有哪些","aria-label":'Permalink to "loader 的作用，常用的 loader 有哪些？"'},"​")],-1),q=s("p",null,"webpack 本身只能处理 JavaScript 和 JSON 文件，而 loader 为 webpack 添加了处理其他类型文件的能力。loader 将其他类型的文件转换成有效的 webpack modules（如 ESmodule、CommonJS、AMD），webpack 能消费这些模块，并将其添加到依赖关系图中。",-1),v=s("p",null,[s("strong",null,"loader 本质上是一个函数，该函数对接收到的内容进行转换，返回转换后的结果。")],-1),P=s("ul",null,[s("li",null,[s("code",null,"@babel/core"),a(": babel 的核心库")]),s("li",null,[s("code",null,"@babel/preset-env"),a(": 规则预设")])],-1),S=s("code",null,'module.exports = "${css}"',-1),A=s("code",null,"<style>",-1),D=s("strong",null,"(一般开发环境使用)",-1),x=s("ul",null,[s("li",null,[s("code",null,"less")])],-1),B=s("ul",null,[s("li",null,[s("code",null,"sass")])],-1),T=s("code",null,"@babel/core",-1),j=s("code",null,"CSS",-1),V=s("code",null,"AST",-1),L=s("code",null,"PostCSS 插件",-1),N=s("ul",null,[s("li",null,[s("code",null,"autoprefixer"),a(": 自动添加浏览器前缀 插件")]),s("li",null,[s("code",null,"post-less"),a(": 兼容 Less 语法的 PostCSS 插件")]),s("li",null,[s("code",null,"post-sass"),a(": 兼容 Sass 语法的 PostCSS 插件")]),s("li",null,[s("code",null,"stylelint"),a(": 一个现代 CSS 代码风格检查器，能够帮助识别样式代码中的异常或风格问题")])],-1),I=s("strong",null,"注意：同时还需要设置插件",-1),W=n(`<div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VueLoaderPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vue-loader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ..</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueLoaderPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>`,1),J=n(`<ul><li><code>webpack5 新增资源模块(asset module)</code>，允许使用资源文件（字体，图标等）内置了以下 loader，无需再安装，只需要设置<code>module.rules.type</code>即可 <ul><li><code>file-loader</code></li><li><code>url-loader</code></li><li><code>raw-loader</code></li></ul></li></ul><h2 id="如何保证-loader-的执行顺序" tabindex="-1">如何保证 loader 的执行顺序？ <a class="header-anchor" href="#如何保证-loader-的执行顺序" aria-label="Permalink to &quot;如何保证 loader 的执行顺序？&quot;">​</a></h2><p>某个规则下，加载不同 loader，如果写在同一个数组中，执行顺序是从右到左。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  module: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rules: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">css</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        use: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style-loader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;css-loader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>同一匹配规则下，写在不同对象中，也可以使用<code>enforce</code>属性来指定执行顺序<code>pre</code>为前置执行，或<code>post</code>为后置执行</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    enforce: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;pre&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指定为前置类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">js</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    loader: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;eslint-loader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">js</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    loader: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;babel-loader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="plugin-的作用-常用的-plugin-有哪些" tabindex="-1">plugin 的作用，常用的 plugin 有哪些？ <a class="header-anchor" href="#plugin-的作用-常用的-plugin-有哪些" aria-label="Permalink to &quot;plugin 的作用，常用的 plugin 有哪些？&quot;">​</a></h2><p>模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成。plugin 理论上可以干涉 webpack 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求。</p>`,8),M=n(`<div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MiniCssExtractPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mini-css-extract-plugin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  module: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rules: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">css</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        use: [MiniCssExtractPlugin.loader, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;css-loader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MiniCssExtractPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>speed-measure-webpack-plugin</p>`,2),$=s("h2",{id:"loader-和-plugin-的区别",tabindex:"-1"},[a("loader 和 plugin 的区别？ "),s("a",{class:"header-anchor",href:"#loader-和-plugin-的区别","aria-label":'Permalink to "loader 和 plugin 的区别？"'},"​")],-1),z=n(`<h2 id="output-中的-publicpath-的作用" tabindex="-1">output 中的 publicPath 的作用？ <a class="header-anchor" href="#output-中的-publicpath-的作用" aria-label="Permalink to &quot;output 中的 publicPath 的作用？&quot;">​</a></h2><p>是资源打包的基础路径, 影响<code>html-webpack-plugin</code>生成的 html 文件引入的 <code>js</code>、<code>css</code>等基础路径。</p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/595701909" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/595701909</a></p><h2 id="output-的-filename-和-chunkfilename-的区别" tabindex="-1">output 的 filename 和 chunkFilename 的区别？ <a class="header-anchor" href="#output-的-filename-和-chunkfilename-的区别" aria-label="Permalink to &quot;output 的 filename 和 chunkFilename 的区别？&quot;">​</a></h2><ul><li><code>filename</code>： 在 entry 中 打包后输出的文件的名称</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;js/[name].[chunkhash:8].js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li><code>chunkFilename</code>：动态 import 时，webpack 会将动态 import 的包，单独打包， 这样子实现按需载入。</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chunkFilename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;js/[name].[chunkhash:8].js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 动态导入时，如果带有魔法注释的话，生成的[name]生成的chunkFilename名字为webpackChunkName指定的名字</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* webpackChunkName: &quot;wavePacking&quot; */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;views/baseinfo/wavePacking/list.vue&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="webpack-的-hash-策略" tabindex="-1">webpack 的 hash 策略？ <a class="header-anchor" href="#webpack-的-hash-策略" aria-label="Permalink to &quot;webpack 的 hash 策略？&quot;">​</a></h2><ul><li><p><code>hash</code>： 属于项目级别的 hash，意思就是整个项目中只要有文件改变该 hash 值就会变化，同时所有文件也都共用该 hash 值。</p></li><li><p><code>chunkhash</code>：产物对应 Chunk 的 Hash，Chunk 中任意模块变化都会产生新的 chunkhash；</p></li><li><p><code>contenthash</code>：属于文件级别的 hash，其会根据文件内容的变化而变化。</p></li></ul><blockquote><p><code>tips</code>：当在 module 中使用 loader 设置图片或者字体的文件名时，如包含 hash 或 chunkhash 都是不生效的，默认会使用 <code>contenthash</code>。</p></blockquote><blockquote><p>将 <code>chunkhash</code> 和 <code>contenthash</code> 组合使用才能最大化的利用 <code>HTTP 缓存中强缓存</code>的优势，减少不必要的资源重复请求，提升网页的整体打开速度。</p></blockquote><h2 id="webpack-中的-sourcemap-是什么-配置策略" tabindex="-1">webpack 中的 sourceMap 是什么，配置策略？ <a class="header-anchor" href="#webpack-中的-sourcemap-是什么-配置策略" aria-label="Permalink to &quot;webpack 中的 sourceMap 是什么，配置策略？&quot;">​</a></h2><p>我们的项目在打包后，将开发环境中源代码经过压缩，去空格，babel 编译等工程化转换，最终的项目代码和源代码之间差异性很大，会造成无法 debug 的问题，在线上环境定位到的代码是压缩处理后的代码。</p><p>而 Sourcemap 就是是为了解决开发代码与实际运行代码不一致时帮助我们 debug 到原始开发代码的技术，解决上述代码定位的问题，是源代码和目标代码出错位置的映射。</p><p><strong>配置策略(dev-tool)</strong></p><ul><li><p>开发环境中使用：<code>cheap-module-eval-source-map</code>（该配置值能保留 loader 处理前的原始代码信息，而打包速度也较快，是一个较佳的选择。）</p></li><li><p>生产环境中使用 <code>sourcemap</code> 会有泄露源代码的风险，但如果要保留定位线上的错误，应该禁止浏览器开发者工具看到源代码，而是用一些<code>错误收集系统</code>，将 <code>sourcemap</code> 文件传到系统上，通过系统 source map 分析出原始代码的错误堆栈，如使用<code>hidden-source-map</code>。</p></li></ul><h2 id="webpack-有哪些缓存优化" tabindex="-1">webpack 有哪些缓存优化？ <a class="header-anchor" href="#webpack-有哪些缓存优化" aria-label="Permalink to &quot;webpack 有哪些缓存优化？&quot;">​</a></h2><p><strong>webpack5 自带的持久化缓存</strong></p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  cache: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;filesystem&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>webpack4 中使用以下方案进行针对性缓存</strong></p><ul><li><code>cache-loader</code>：针对 Loader 运行结果的通用缓存方案；</li><li><code>hard-source-webpack-plugin</code>：针对 Webpack 全生命周期的通用缓存方案；</li><li><code>babel-loader</code>：针对 Babel 工具的专用缓存能力；</li><li><code>eslint-loader/eslint-webpack-plugin</code>：针对 ESLint 的专用缓存方案；</li><li><code>stylelint-webpack-plugin</code>：针对 StyleLint 的专用缓存方案。</li></ul><h2 id="webpack-构建流程-工作原理" tabindex="-1">webpack 构建流程(工作原理)？ <a class="header-anchor" href="#webpack-构建流程-工作原理" aria-label="Permalink to &quot;webpack 构建流程(工作原理)？&quot;">​</a></h2><h2 id="chunk-module-是什么" tabindex="-1">chunk，module 是什么？ <a class="header-anchor" href="#chunk-module-是什么" aria-label="Permalink to &quot;chunk，module 是什么？&quot;">​</a></h2><p><code>module</code>: 就是模块</p><p><code>chunk</code>: 是 module 容器，根据 splitChunks 设定的 策略 优化分包，决定最终输出多少产物文件（一个或者多个 module 打包后的生成的文件）</p><h2 id="什么是代码分割-code-splitting" tabindex="-1">什么是代码分割（Code Splitting）？ <a class="header-anchor" href="#什么是代码分割-code-splitting" aria-label="Permalink to &quot;什么是代码分割（Code Splitting）？&quot;">​</a></h2><h2 id="如何实现代码混淆" tabindex="-1">如何实现代码混淆？ <a class="header-anchor" href="#如何实现代码混淆" aria-label="Permalink to &quot;如何实现代码混淆？&quot;">​</a></h2><p>代码混淆的重点是使得源代码不具有可读性</p><h2 id="webpack-如何实现并行构建" tabindex="-1">webpack 如何实现并行构建？ <a class="header-anchor" href="#webpack-如何实现并行构建" aria-label="Permalink to &quot;webpack 如何实现并行构建？&quot;">​</a></h2><h2 id="tree-shaking-的原理" tabindex="-1">Tree Shaking 的原理？ <a class="header-anchor" href="#tree-shaking-的原理" aria-label="Permalink to &quot;Tree Shaking 的原理？&quot;">​</a></h2><h2 id="热更新的原理" tabindex="-1">热更新的原理？ <a class="header-anchor" href="#热更新的原理" aria-label="Permalink to &quot;热更新的原理？&quot;">​</a></h2><h2 id="异步加载-懒加载-原理" tabindex="-1">异步加载(懒加载)原理？ <a class="header-anchor" href="#异步加载-懒加载-原理" aria-label="Permalink to &quot;异步加载(懒加载)原理？&quot;">​</a></h2><p><a href="https://juejin.cn/post/7152516872330543141" target="_blank" rel="noreferrer">https://juejin.cn/post/7152516872330543141</a></p><h2 id="source-map-是什么-平时怎么配置的" tabindex="-1">Source Map 是什么，平时怎么配置的？ <a class="header-anchor" href="#source-map-是什么-平时怎么配置的" aria-label="Permalink to &quot;Source Map 是什么，平时怎么配置的？&quot;">​</a></h2><h2 id="生产环境构建时为什么要将-css-提取到单独的文件" tabindex="-1">生产环境构建时为什么要将 css 提取到单独的文件？ <a class="header-anchor" href="#生产环境构建时为什么要将-css-提取到单独的文件" aria-label="Permalink to &quot;生产环境构建时为什么要将 css 提取到单独的文件？&quot;">​</a></h2><ol><li><p><strong>更好的利用缓存</strong>，当 <code>css</code> 和 <code>js</code> 分开时，浏览器可以缓存 <code>css</code>文件并重复使用，而不必重新加载，也不用因为<code>js</code>内容的变化，导致<code>css</code>缓存失效。</p></li><li><p><strong>更快的渲染速度</strong>，浏览器是同时可以并行加载多个静态资源，将 <code>css</code> 单独提取出俩，有助于加快 <code>js</code> 加载和解析速度，最终加快页面的渲染速度。</p></li><li><p><strong>方便代码调试</strong>, 独立的 <code>css</code> 文件有助于代码阅读和调试。</p></li></ol><h2 id="tapable-是什么" tabindex="-1">Tapable 是什么？ <a class="header-anchor" href="#tapable-是什么" aria-label="Permalink to &quot;Tapable 是什么？&quot;">​</a></h2><h2 id="webpack-如何优化打包速度" tabindex="-1">webpack 如何优化打包速度？ <a class="header-anchor" href="#webpack-如何优化打包速度" aria-label="Permalink to &quot;webpack 如何优化打包速度？&quot;">​</a></h2><h2 id="webpack-如何优化打包体积" tabindex="-1">webpack 如何优化打包体积？ <a class="header-anchor" href="#webpack-如何优化打包体积" aria-label="Permalink to &quot;webpack 如何优化打包体积？&quot;">​</a></h2><p>代码混淆：代码混淆的重点是使得源代码不具有可读性</p><p>代码压缩：代码压缩重点是使得代码的体积最小</p><p>分包</p><p>externals</p><p>Tree-Shaking：mode porduction 默认启动，在 Webpack 中使用 babel-loader 时，建议将 babel-preset-env 的 moduels 配置项设置为 false，关闭模块导入导出语句的转译</p><p>动态加载(异步加载)</p><p>external</p><h2 id="webpack5-有哪些新特性" tabindex="-1">webpack5 有哪些新特性？ <a class="header-anchor" href="#webpack5-有哪些新特性" aria-label="Permalink to &quot;webpack5 有哪些新特性？&quot;">​</a></h2><ul><li>模块联邦</li><li>持久化缓存</li><li>lazyCompilation</li></ul>`,49),R={id:"进阶",tabindex:"-1"},H=s("a",{class:"header-anchor",href:"#进阶","aria-label":'Permalink to "<font color="red">================== 进阶 =================</font>"'},"​",-1);function O(U,G,K,Q,X,Y){const l=t("font");return h(),o("div",null,[s("h2",d,[i(l,{color:"red"},{default:e(()=>[a("================== 基础 =================")]),_:1}),a(),c]),k,s("h3",u,[i(l,{color:"blue"},{default:e(()=>[a("1. 流程类：")]),_:1}),a(" 作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项 "),b]),s("p",null,[s("strong",null,[i(l,{color:"red"},{default:e(()=>[a("输入输出：")]),_:1})])]),E,s("p",null,[s("strong",null,[i(l,{color:"red"},{default:e(()=>[a("模块处理：")]),_:1})])]),g,s("p",null,[s("strong",null,[i(l,{color:"red"},{default:e(()=>[a("后处理：")]),_:1})])]),m,s("h3",_,[i(l,{color:"blue"},{default:e(()=>[a("2. 工具类：")]),_:1}),a(" 打包主流程之外，提供更多工程化工具的配置项 "),y]),s("p",null,[s("strong",null,[i(l,{color:"red"},{default:e(()=>[a("开发效率类：")]),_:1})])]),F,s("p",null,[s("strong",null,[i(l,{color:"red"},{default:e(()=>[a("性能优化类：")]),_:1})])]),f,s("p",null,[s("strong",null,[i(l,{color:"red"},{default:e(()=>[a("日志类：")]),_:1})])]),C,w,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("概念：")]),_:1})])]),q,v,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("babel-loader")]),_:1})]),a(": ES6+转译为低版本 JS，需要同时安装以下模块")]),P,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("css-loader")]),_:1})]),a(": 该 Loader 会将 CSS 等价翻译为形如 "),S,a(" 的 JavaScript 代码，使得 Webpack 能够如同处理 JS 代码一样解析 CSS 内容与资源依赖")]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("style-loader")]),_:1})]),a(": 该 Loader 将在产物中注入一系列 runtime 代码，这些代码会将 CSS 内容注入到页面的 "),A,a(" 标签，使得样式生效 "),D]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("less-loader")]),_:1})]),a(": less 预处理器转换 css，需要同时安装以下模块")]),x,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("sass-loader")]),_:1})]),a(": sass 预处理器转换 css，需要同时安装以下模块")]),B,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("postcss-loader")]),_:1})]),a(": 与 "),T,a(" 类似，只是实现了一套将 "),j,a(" 源码解析为 "),V,a(" 结构，并传入 "),L,a("做处理的流程框架，具体功能都由插件实现。")]),N,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("ts-loader")]),_:1})]),a(": ts 转 js")]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("vue-loader")]),_:1})]),a(": 处理 Vue SFC(Single File Component) 文件(*.vue)。"),I]),W,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("image-webpack-loader")]),_:1})]),a(":")]),J,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("html-webpack-plugin")]),_:1})]),a(": 生成 html 文件，在 body 中使用 script 标签引入你所有 webpack 生成的 bundle。")]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("copy-webpack-plugin")]),_:1})]),a(": 某些静态资源不想打包，而是在打包过程中，通过拷贝的方式到指定目录。")]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("webpack.DefinePlugin(内置插件)")]),_:1})]),a(": 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和生产模式的构建允许不同的行为非常有用。")]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("webpack.ProvidePlugin(内置插件)")]),_:1})]),a(": 用来全局引入某个包，而非使用静态页面 script 引入，例如引入 jquery，先安装 jquery 包，然后通过 ProvidePlugin 全局引入。")]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("clean-webpack-plugin")]),_:1})])]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("mini-css-extract-plugin")]),_:1})]),a(": webpack5 中 单独提取 js 中引入的 css 为单独文件。")]),M,s("p",null,[a("uglifyjs-webpack-plugin "),s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a("eslint-webpack-plugin")]),_:1})]),a(": 通过 ESLint 检查 JavaScript 代码")]),$,s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a('Loader 直译为"加载器"')]),_:1})]),a(": Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。")]),s("p",null,[s("strong",null,[i(l,{color:"blue"},{default:e(()=>[a('Plugin 直译为"插件"')]),_:1})]),a(": Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。")]),z,s("h2",R,[i(l,{color:"red"},{default:e(()=>[a("================== 进阶 =================")]),_:1}),a(),H])])}const as=p(r,[["render",O]]);export{ss as __pageData,as as default};
