import{_ as n,D as r,o as s,c as _,k as o,I as c,w as d,a as l,R as t}from"./chunks/framework.4hIqoSk1.js";const a="/larry-book-vite/assets/01.YcjHWyMa.png",u="/larry-book-vite/assets/02.0cggyvJJ.png",qo=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"browser/架构-渲染.md","filePath":"browser/架构-渲染.md","lastUpdated":1733279472000}'),i={name:"browser/架构-渲染.md"},p=o("p",null,[l("tip 大部分都是围绕 "),o("code",null,"chromium"),l("内核 浏览器来说，面试也是基于这个内核去问。")],-1),h=o("h2",{id:"chrome、chromium、v8-分别是什么",tabindex:"-1"},[l("Chrome、Chromium、V8 分别是什么？ "),o("a",{class:"header-anchor",href:"#chrome、chromium、v8-分别是什么","aria-label":'Permalink to "Chrome、Chromium、V8 分别是什么？"'},"​")],-1),S=o("p",null,[o("code",null,"Chromium"),l("是谷歌的开源项目，我们平时说的基于 "),o("strong",null,"谷歌浏览器内核"),l(" 的浏览器其实说的是基于"),o("code",null,"Chromium"),l("内核来开发自己的浏览器。更多面向的是 开发人员。")],-1),g=o("code",null,"Chrome",-1),T=o("a",{href:"https://blog.csdn.net/fuhanghang/article/details/112859503",target:"_blank",rel:"noreferrer"},"Chrome V8 引擎介绍",-1),f=t('<p><code>chrome v8</code> 也可以简单的说成<code>v8</code>, 是一个开源的 <code>javascript</code> 引擎, 它是由谷歌 <code>Chromium</code> 项目团队开发, 应用在 <code>chrome</code> 和基于 <code>chromium</code> 浏览器上. 这个项目由 Lars Bak 创建. <code>V8</code> 引擎的第一个版本发行时间和 <code>Chrome</code> 的第一个版本发行时间是一样的: 2008 年 9 月 2 号. 它同样也用在 Couchbase, MongoDB 和 node.js 上.</p><p><code>V8</code> 在执行 <code>javascript</code> 之前, 会将 <code>javascript</code> 编译成本地机器代码, 来代替更多的传统技术, 比如解释字节码或者编译整个应用程序到机器码, 且从一个文件系统执行它. 编译代码是在运行时动态的优化, 基于代码执行情况的启发式方式. 优化技术的使用包含 inlining, 消耗运行时性能的 elision, 还有 inline caching.</p><p>V8 可以编译成 x86, ARM 或者 MIPS 指令设置结构的 32 位或者 64 位版本; 同样他也被安装在 PowerPC 和 IBM s390 服务器上.</p><p><a href="https://juejin.cn/post/6914479519394955271#heading-3" target="_blank" rel="noreferrer">参考文章</a><a href="https://github.com/webfansplz/article/issues/39" target="_blank" rel="noreferrer">参考文章</a></p><h2 id="进程-和-线程的区别" tabindex="-1">进程 和 线程的区别？ <a class="header-anchor" href="#进程-和-线程的区别" aria-label="Permalink to &quot;进程 和 线程的区别？&quot;">​</a></h2>',5),m=o("code",null,"CPU",-1),b=o("strong",null,"资源分配",-1),C=o("code",null,"CPU",-1),P=o("strong",null,"调度",-1),k=o("p",null,[o("strong",null,"区别：")],-1),M=o("li",null,[o("p",null,"创建和销毁线程的开销较小，而创建和销毁进程的开销较大。")],-1),A=o("li",null,[o("p",null,"多线程程序的编程复杂度通常比单线程程序高，但多线程可以更好地利用多核处理器来提高程序的执行效率。")],-1),D=o("h2",{id:"浏览器都有哪些进程",tabindex:"-1"},[l("浏览器都有哪些进程？ "),o("a",{class:"header-anchor",href:"#浏览器都有哪些进程","aria-label":'Permalink to "浏览器都有哪些进程？"'},"​")],-1),J=o("ul",null,[o("li",null,[l("主要负责"),o("strong",null,"界面显示"),l("、"),o("strong",null,"用户交互"),l("、"),o("strong",null,"子进程管理"),l("，同时提供"),o("strong",null,"存储"),l("等功能。")])],-1),I=t("<ul><li>核心任务是将 <code>HTML</code>、<code>CSS</code> 和 <code>JavaScript</code> 转换为用户可以与之交互的网页，排版引擎 <code>Blink</code> 和 <code>JavaScript</code> 引擎 <code>V8</code> 都是运行在该进程中，默认情况下，<code>Chrome</code> 会为每个 <code>Tab</code> 标签创建一个<strong>渲染进程</strong>。出于安全考虑，<strong>渲染进程</strong> 都是运行在<strong>沙箱模式下</strong>。</li></ul>",1),V=t("<ul><li>其实，<code>Chrome</code> 刚开始发布的时候是没有 <code>GPU</code> 进程的。而 <code>GPU</code> 的使用初衷是为了实现 <code>3D CSS</code> 的效果，只是随后网页、<code>Chrome</code> 的 <code>UI</code> 界面都选择采用 <code>GPU</code> 来绘制，这使得 <code>GPU</code> 成为浏览器普遍的需求。最后，<code>Chrome</code> 在其多进程架构上也引入了 <strong>GPU 进程</strong>。</li></ul>",1),v=o("ul",null,[o("li",null,[l("主要负责页面的"),o("strong",null,"网络资源加载"),l("，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")])],-1),O=o("ul",null,[o("li",null,"主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")],-1),R=o("p",null,[o("img",{src:a,alt:"概览图"})],-1),N=o("h2",{id:"渲染进程有哪些线程",tabindex:"-1"},[l("渲染进程有哪些线程？ "),o("a",{class:"header-anchor",href:"#渲染进程有哪些线程","aria-label":'Permalink to "渲染进程有哪些线程？"'},"​")],-1),L=t("<li><p>负责渲染浏览器界面,解析 <code>HTML</code>,<code>CSS</code>,构建 <code>DOM</code> 树和 <code>RenderObject</code> 树,布局和绘制等。</p></li><li><p>当界面需要重绘（<code>Repaint</code>）或由于某种操作引发回流(<code>reflow</code>)时,该线程就会执行。</p></li>",2),U=o("code",null,"GUI",-1),E=o("code",null,"JS 引擎",-1),q=o("li",null,[o("p",null,[o("code",null,"Javascript"),l(" 引擎,也称为 "),o("code",null,"JS"),l(" 内核,负责处理 "),o("code",null,"Javascript"),l(" 脚本程序。（例如 V8 引擎）")])],-1),x=o("code",null,"Javascript",-1),y=t("<ul><li><p>平时我们说的<code>event loop</code> 归属于<strong>浏览器</strong>而不是 <strong>JS 引擎</strong>, 用来控制事件循环（可以理解,JS 引擎自己都忙不过来,需要浏览器另开线程协助）</p></li><li><p>当 JS 引擎执行代码块如 <code>setTimeOut</code> 时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等）,会将对应任务添加到<strong>事件线程</strong>中。</p></li><li><p>当对应的事件符合触发条件被触发时,该线程会把事件添加到待处理队列的队尾,等待 <strong>JS 引擎</strong>的处理</p></li><li><p>注意,由于 JS 的单线程关系,所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</p></li></ul>",1),j=o("ul",null,[o("li",null,[o("p",null,[l("传说中的 "),o("code",null,"setInterval"),l(" 与 "),o("code",null,"setTimeout"),l(" 所在线程")])]),o("li",null,[o("p",null,"浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）")]),o("li",null,[o("p",null,"因此通过单独线程来计时并触发定时（计时完毕后,添加到事件队列中,等待 JS 引擎空闲后执行）")]),o("li",null,[o("p",null,"注意,W3C 在 HTML 标准中规定,规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。")])],-1),w=t('<ul><li><p>在 <code>XMLHttpRequest</code> 在连接后是通过浏览器新开一个线程请求。</p></li><li><p>将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件,将这个回调再放入事件队列中。再由 <code>JavaScript</code> 引擎执行。</p></li></ul><p><img src="'+u+'" alt="渲染线程概览"></p><h2 id="浏览器为什么要区分微任务和宏任务" tabindex="-1">浏览器为什么要区分微任务和宏任务？ <a class="header-anchor" href="#浏览器为什么要区分微任务和宏任务" aria-label="Permalink to &quot;浏览器为什么要区分微任务和宏任务？&quot;">​</a></h2><p><code>为了插队。</code></p><p>一个 Event Loop，Microtask 是在 Macrotask 之后调用，Microtask 会在下一个 Event Loop 之前执行调用完，并且其中会将 Microtask 执行当中新注册的 Microtask 一并调用执行完，然后才开始下一次 Event loop，所以如果有新的 Macrotask 就需要一直等待，等到上一个 Event loop 当中 Microtask 被清空为止。由此可见， 我们可以在下一次 Event loop 之前进行插队。如果不区分 Microtask 和 Macrotask，那就无法在下一次 Event loop 之前进行插队，其中新注册的任务得等到下一个 Macrotask 完成之后才能进行，这中间可能你需要的状态就无法在下一个 Macrotask 中得到同步。状态的同步对于视图来说至关重要，这也就牵扯到了为什么 javascript 是单线程的原因所在。</p><h2 id="为什么-js-是单线程的" tabindex="-1">为什么 JS 是单线程的？ <a class="header-anchor" href="#为什么-js-是单线程的" aria-label="Permalink to &quot;为什么 JS 是单线程的？&quot;">​</a></h2>',6),G=o("code",null,"JavaScript",-1),H=o("code",null,"UI DOM",-1),Y=o("code",null,"UI",-1),B=o("code",null,"Javascript",-1),K=o("blockquote",null,[o("p",null,"想下 浏览器渲染进程 架构的 五个 线程，会帮 JS 引擎线程 解决单线程带来的问题。")],-1),$=o("h2",{id:"js-会阻塞页面渲染吗",tabindex:"-1"},[l("JS 会阻塞页面渲染吗？ "),o("a",{class:"header-anchor",href:"#js-会阻塞页面渲染吗","aria-label":'Permalink to "JS 会阻塞页面渲染吗？"'},"​")],-1),W=o("p",null,[l("会的，参考上边 "),o("strong",null,"JS 引擎线程"),l(" 和 "),o("strong",null,"GUI 渲染线程"),l(" 互斥")],-1),X=o("h2",{id:"css-会阻塞页面渲染吗",tabindex:"-1"},[l("CSS 会阻塞页面渲染吗？ "),o("a",{class:"header-anchor",href:"#css-会阻塞页面渲染吗","aria-label":'Permalink to "CSS 会阻塞页面渲染吗？"'},"​")],-1),z=o("strong",null,"DOM 解析",-1),F=o("strong",null,"CSS 解析",-1),Q=o("code",null,"Render Tree",-1),Z=o("code",null,"DOM Tree",-1),oo=o("code",null,"CSSOM Tree",-1),lo=o("code",null,"CSSOM Tree",-1),eo=o("code",null,"CSS",-1),co=o("code",null,"CSS",-1),to=o("h2",{id:"domcontentloaded-与-load-的区别",tabindex:"-1"},[l("DOMContentLoaded 与 load 的区别？ "),o("a",{class:"header-anchor",href:"#domcontentloaded-与-load-的区别","aria-label":'Permalink to "DOMContentLoaded 与 load 的区别？"'},"​")],-1),no=o("ul",null,[o("li",null,[l("当整个页面及"),o("strong",null,"所有依赖资源"),l("都已完成加载时，将触发 "),o("code",null,"load"),l(" 事件。")])],-1),ro=t('<ul><li>仅当 <code>DOM</code> 解析完成后, 不包括样式表, 图片，会触发 <code>DOMContentLoaded</code> 事件</li></ul><h2 id="script-标签中的-defer-和-async-的区别" tabindex="-1">script 标签中的 defer 和 async 的区别？ <a class="header-anchor" href="#script-标签中的-defer-和-async-的区别" aria-label="Permalink to &quot;script 标签中的 defer 和 async 的区别？&quot;">​</a></h2><ul><li><strong>defer 并行加载 js 文件，会按照页面上 script 标签的顺序执行</strong></li><li><strong>async 并行加载 js 文件，下载完成立即执行，不会按照页面上 script 标签的顺序执行</strong></li></ul><p><strong>defer</strong></p><ul><li><p><code>defer</code> 延迟属性可以使浏览器不需要等待脚本的下载，浏览器会继续处理 html 构建 DOM，直到完全构建完 DOM 后才会执行脚本。就是总是在 DOM 构建完之后才会执行，在 <code>DOMContentLoaded</code> 事件之前执行。</p></li><li><p><code>defer</code> 脚本保持相对顺序来执行，就像常规脚本一样。多个 <code>defer</code> 脚本会并行下载，但执行的时候会按照顺序执行。</p></li><li><p><code>webpack</code> 打包后 <code>htmlWabpackPlugin</code> 会默认生成为 <code>defer</code> 脚本引入 <code>bundle。</code></p></li></ul><p><strong>async</strong></p><ul><li><code>async</code> 异步加载脚本，不会阻塞页面渲染。</li><li><code>DOMContentLoaded</code> 可能发生在 <code>async</code> <strong>之前</strong> 或 <strong>之后</strong></li><li><code>async</code> 加载脚本完脚本会立即执行，可以在 <code>DOM</code> 尚未完全下载完成就加载和执行。</li><li>一般将没有依赖的独立的第三方脚本设置成 <code>async</code></li></ul><h2 id="图片-视频-字体会阻塞页面渲染嘛" tabindex="-1">图片/视频/字体会阻塞页面渲染嘛？ <a class="header-anchor" href="#图片-视频-字体会阻塞页面渲染嘛" aria-label="Permalink to &quot;图片/视频/字体会阻塞页面渲染嘛？&quot;">​</a></h2><p>不会阻塞 <code>DOM</code> 的解析 和 渲染，并且不会影响 <code>DOMContentLoaded</code> 事件的触发，当图片/视频等加载完成后才会触发 <code>load</code> 事件。</p><h2 id="回流-和-重绘-的区别" tabindex="-1">回流 和 重绘 的区别？ <a class="header-anchor" href="#回流-和-重绘-的区别" aria-label="Permalink to &quot;回流 和 重绘 的区别？&quot;">​</a></h2>',10),so=o("ul",null,[o("li",null,[l("当 "),o("code",null,"Render Tree"),l(" 中部分或全部元素的尺寸、结构、或某些属性发生改变时, 浏览器重新渲染部分或全部文档的过程称为"),o("strong",null,"回流"),l("。")])],-1),_o=t('<ul><li>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color``、visibility</code> 等）,浏览器会将新样式赋予给元素并重新绘制它,这个过程称为<strong>重绘</strong>。</li></ul><p><strong>注意：回流必将引起重绘, 重绘不一定会引起回流。</strong></p><h2 id="页面渲染流程-原理-重点" tabindex="-1">页面渲染流程/原理(重点)？ <a class="header-anchor" href="#页面渲染流程-原理-重点" aria-label="Permalink to &quot;页面渲染流程/原理(重点)？&quot;">​</a></h2><ol><li><p>解析 <code>html</code> 文件，构建 <code>DOM</code> 树，这期间也有对 <code>JS</code> 脚本的下载和 <code>CSS</code> 的下载。下载 <code>CSS</code> 和构建 <code>DOM</code> 是并行的。</p></li><li><p><code>CSS</code> 文件下载完成,解析 <code>CSS</code> 文件生成树形的数据结构（<code>CSSOM</code>）,然后结合 <code>DOM</code> 树合并成 <code>RenderObject</code>（渲染） 树。</p></li><li><p>然后会对 <code>RenderObject</code> 树进行 <strong>布局</strong>, 进行元素尺寸、位置等计算。</p></li><li><p>然后会对 <code>RenderObject</code> 树进行 <strong>绘制</strong>, 绘制页面的像素信息。</p></li><li><p>浏览器主进程将默认的图层和复合图层交给 <code>GPU</code> 进程,<code>GPU</code> 进程再将各个图层合成（composite）,最后显示出页面。</p></li></ol><h2 id="从输入-url-到页面展示的过程-重点" tabindex="-1">从输入 URL 到页面展示的过程(重点)？ <a class="header-anchor" href="#从输入-url-到页面展示的过程-重点" aria-label="Permalink to &quot;从输入 URL 到页面展示的过程(重点)？&quot;">​</a></h2><p><a href="https://segmentfault.com/a/1190000041553527" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000041553527</a></p><blockquote><p>这个问题，虽然问烂了，但考察的知识点特别多，能回答到什么程度，就看知识覆盖面了。 比如输入www.baidu.com</p></blockquote>',7),ao=o("code",null,"1. URL 解析(编码)",-1),uo=o("ul",null,[o("li",null,[l("会检查 "),o("code",null,"url"),l(" 的拼写 "),o("ul",null,[o("li",null,[l("如果是 文本，则拼接成默认搜索引擎加关键字的 "),o("code",null,"URL"),l(" 进行搜索")]),o("li",null,"如果是 URL 就进行页面访问请求，并加上协议头（http、https）")])])],-1),io=o("p",null,[o("strong",null,[o("code",null,"2. 检查缓存")])],-1),po=o("code",null,"2. DNS 解析",-1),ho=t("<p>因为浏览器不能直接通过域名找到对应的服务器 <code>IP</code> 地址，所以需要进行 <code>DNS</code> 解析，查找到对应的 <code>IP</code> 地址进行访问。</p><ul><li>(1) 先检查本地的 <code>hosts</code> 文件中，是否有这个网址记录，有则从记录里面找到对应的 <code>IP</code> 地址，完成域名解析。</li><li>(2) 如果本地<code>hosts</code>文件没有映射，去查找 本地<strong>dns 解析器</strong>是否有缓存, 又就返回。</li><li>(3) 然后去我们配置的 <strong>dns 服务器上</strong> 查看是否有或者 是否有缓存， 有就返回。</li><li>(4) 还没有的话就去找根 DNS 服务器(全球 13 台，固定 ip 地址)，然后判断<code>.com</code>域名是哪个服务器管理，如果无法解析，就查找<code>.baidu.com</code>服务器是否能解析，直到查到<code>www.baidu.com</code>的<code>IP</code>地址。</li></ul>",2),So=o("code",null,"3. 建立 TCP 连接",-1),go=t("<ul><li><p>通过三次握手</p><ol><li><p>客户端发送 <code>SYN 包（seq = j）</code>到服务器，并进入 <code>SYN_SEND</code> 状态，等待服务器确认。</p></li><li><p>服务器收到 SYN 包，必须确认客户的 <code>SYN（ACK = k + 1）</code>，同时自己也发送一个 <code>SYN 包（seq = k）</code>，即 <code>SYN+ACK</code> 包，此时服务器进入 <code>SYN_RECV</code> 状态。</p></li><li><p>客户端收到服务器的 <code>SYN+ACK</code> 包，向服务器发送确认包 <code>ACK（ACK = k + 1）</code>，此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code> 状态，完成三次握手。</p></li></ol></li></ul>",1),To=o("code",null,"4. 发送HTTP/HTTPS请求",-1),fo=t("<ul><li><p>如果是 <code>http</code> 协议，则直接<code>构建/发送</code>请求头信息。</p></li><li><p>如果是 <code>https</code> 协议，会在 <code>TCP</code> 与 <code>HTTP</code> 之间多添加一层协议做加密及认证的服务, HTTPS 使用 <code>SSL</code>（Secure Socket Layer） 和 <code>TLS</code>（Transport Layer Security） 协议，保障了信息的安全。</p></li></ul>",1),mo=o("code",null,"5. 服务器响应请求",-1),bo=t("<ul><li><p>服务器收到请求后，将发回一个 HTTP <code>响应报文</code>，内容包括相关响应头和 HTML 正文。</p></li><li><p>检查状态码，如果是<code>301/302</code>，则需要重定向，需要重复上面步骤。</p></li><li><p>状态码如果是<code>304</code> 这种就读取缓存。</p></li><li><p>状态吗，如果是<code>200</code>，则检查响应类型<code>Content-Type</code>，如果是<code>字节流类型</code>，则将该请求提交给<code>下载管理器</code>，该导航流程结束，不再进行后续的渲染，如果是<code>html</code>则通知浏览器进程准备渲染进程准备进行渲染。</p></li></ul>",1),Co=o("code",null,"6. 浏览器解析渲染页面",-1),Po=o("p",null,[o("strong",null,"参考页面渲染原理")],-1),ko=o("p",null,[o("code",null,"7. TCP断开连接(默认是keep-alive)")],-1),Mo=o("p",null,[l("现在的页面为了优化请求的耗时，默认都会开启持久连接"),o("code",null,"（keep-alive）"),l("，那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是"),o("code",null,"四次挥手"),l("。关闭是一个全双工的过程，发包的顺序是不一定的。")],-1),Ao=o("h2",{id:"浏览器渲染优化有哪些手段",tabindex:"-1"},[l("浏览器渲染优化有哪些手段？ "),o("a",{class:"header-anchor",href:"#浏览器渲染优化有哪些手段","aria-label":'Permalink to "浏览器渲染优化有哪些手段？"'},"​")],-1),Do=t("<ul><li><p><code>JavaScript</code>会阻塞 HTML 的解析 将<code>JavaScript</code>放到 <code>body</code> 最后面</p></li><li><p>尽量使用异步加载<code>JS</code>资源，这样不会阻塞<code>DOM</code>解析，如<code>defer</code>、<code>async</code></p></li></ul>",1),Jo=o("ul",null,[o("li",null,[o("code",null,"CSS"),l("样式少，使用内嵌样式")]),o("li",null,[l("导入外部样式使用"),o("code",null,"link"),l("，而不是"),o("code",null,"@import"),l("，因为它会阻塞渲染。")])],-1),Io=o("ul",null,[o("li",null,"避免频繁操作样式"),o("li",null,"避免频繁操作 DOM"),o("li",null,"复杂动画使用定位脱离文当流"),o("li",null,"使用 transform 替代动画")],-1);function Vo(vo,Oo,Ro,No,Lo,Uo){const e=r("font");return s(),_("div",null,[p,h,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("Chromium")]),_:1})])]),S,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("Chrome")]),_:1})]),g,l("是谷歌对外的浏览器，不是开源的，面向的是普通用户、开发人员。")]),o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("V8")]),_:1})]),T]),f,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("进程: ")]),_:1})]),l(" 进程是 "),m,l(),b,l(" 的最小单位（是能拥有资源和独立运行的最小单位）。")]),o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("线程：")]),_:1})]),l(" 线程是 "),C,l(),P,l(" 的最小单位（是建立在进程基础上的一次程序运行单位）。")]),k,o("ul",null,[o("li",null,[o("p",null,[l("进程和线程都可以实现并发执行，但进程是独立的执行实体，而"),c(e,{color:"red"},{default:d(()=>[l("线程是依赖于进程的")]),_:1}),l("。")])]),o("li",null,[o("p",null,[l("进程之间资源相互隔离，"),c(e,{color:"red"},{default:d(()=>[l("线程共享所属进程的资源")]),_:1}),l("。")])]),M,A]),D,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("浏览器主进程：")]),_:1})])]),J,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l(" 渲染进程：")]),_:1})])]),I,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l(" GPU 进程：")]),_:1})])]),V,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l(" 网络进程：")]),_:1})])]),v,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l(" 插件进程：")]),_:1})])]),O,R,N,o("p",null,[o("strong",null,[l("平时我们说的 浏览器是"),c(e,{color:"red"},{default:d(()=>[l("多线程的")]),_:1}),l("指得是，浏览器中的 "),c(e,{color:"red"},{default:d(()=>[l("渲染进程")]),_:1}),l(" 是多线程的")])]),o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("1. GUI 渲染线程")]),_:1})])]),o("ul",null,[L,o("li",null,[o("p",null,[l("注意,"),c(e,{color:"red"},{default:d(()=>[l("GUI 渲染线程")]),_:1}),l(" 与 "),c(e,{color:"red"},{default:d(()=>[l("JS 引擎线程")]),_:1}),l("是互斥的,当 "),c(e,{color:"red"},{default:d(()=>[l("JS 引擎")]),_:1}),l("执行时 "),c(e,{color:"red"},{default:d(()=>[l("GUI 线程")]),_:1}),l("会被挂起（相当于被冻结了）,"),U,l(" 更新会被保存在一个队列中等到 "),E,l("空闲时立即被执行。")])])]),o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("2. JS 引擎线程（V8 引擎）")]),_:1})])]),o("ul",null,[q,o("li",null,[c(e,{color:"red"},{default:d(()=>[l("JS 引擎线程")]),_:1}),l(" 负责解析 "),x,l(" 脚本,运行代码。")]),o("li",null,[o("p",null,[l("JS 引擎一直等待着任务队列中任务的到来,然后加以处理,一个 Tab 页（renderer 进程）中无论什么时候都只有一个 JS 线程在运行 JS 程序, 这就是我们平时说的 "),c(e,{color:"red"},{default:d(()=>[l("JS 是单线程的")]),_:1})])]),o("li",null,[o("p",null,[l("注意,"),c(e,{color:"red"},{default:d(()=>[l("GUI 渲染线程")]),_:1}),l("与 "),c(e,{color:"red"},{default:d(()=>[l("JS 引擎线程")]),_:1}),l("是互斥的,所以如果 JS 执行的时间过长,这样就会造成页面的渲染不连贯,导致页面渲染加载阻塞。")])])]),o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("3. 事件触发线程（事件循环）")]),_:1})])]),y,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("4. 定时触发器线程")]),_:1})])]),j,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("5. 异步 http 请求线程")]),_:1})])]),w,o("p",null,[l("其实上面已经说过了，如果 "),G,l(" 是多线程的方式来操作这些 "),H,l(",则可能出现 "),Y,l(" 操作的冲突。当然我们可以通过 "),c(e,{color:"red"},{default:d(()=>[l("锁")]),_:1}),l(" 来解决上面的问题。但为了避免因为引入了 "),c(e,{color:"red"},{default:d(()=>[l("锁")]),_:1}),l(" 而带来更大的复杂性,"),B,l(" 在最初就选择了单线程执行。")]),K,$,W,X,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("会的！！")]),_:1})])]),o("p",null,[z,l(" 和 "),F,l("是并行的, 所以 "),o("strong",null,[c(e,{color:"red"},{default:d(()=>[l("CSS 加载不会阻塞 DOM 的解析(在没有 JS 脚本的情况下)")]),_:1})]),l("。 然而,由于 "),Q,l("(渲染树) 是依赖于 "),Z,l(" 和 "),oo,l(" 的, 所以他必须等待到 "),lo,l(" 构建完成,也就是 "),eo,l(" 资源加载完成(或者 "),co,l(" 资源加载失败)后,才能开始渲染。因此,"),o("strong",null,[c(e,{color:"red"},{default:d(()=>[l("CSS 加载会阻塞 DOM 的渲染")]),_:1})])]),to,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("load")]),_:1})])]),no,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("DOMContentLoaded")]),_:1})])]),ro,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("回流(Reflow)")]),_:1})])]),so,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("重绘(Repaint)")]),_:1})])]),_o,o("p",null,[o("strong",null,[ao,l(" -- "),c(e,{color:"blue"},{default:d(()=>[l("浏览器主进程")]),_:1})])]),uo,io,o("p",null,[o("strong",null,[po,l(" -- "),c(e,{color:"red"},{default:d(()=>[l("网络进程")]),_:1})])]),ho,o("p",null,[o("strong",null,[So,l(" -- "),c(e,{color:"red"},{default:d(()=>[l("网络进程")]),_:1})])]),go,o("p",null,[o("strong",null,[To,l(" -- "),c(e,{color:"red"},{default:d(()=>[l("网络进程")]),_:1})])]),fo,o("p",null,[o("strong",null,[mo,l(" -- "),c(e,{color:"red"},{default:d(()=>[l("网络进程")]),_:1})])]),bo,o("p",null,[o("strong",null,[Co,l(" -- "),c(e,{color:"orange"},{default:d(()=>[l("渲染进程")]),_:1})])]),Po,ko,Mo,Ao,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("优化 JavaScript")]),_:1})])]),Do,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("优化 CSS 加载")]),_:1})])]),Jo,o("p",null,[o("strong",null,[c(e,{color:"blue"},{default:d(()=>[l("减少回流重绘")]),_:1})])]),Io])}const xo=n(i,[["render",Vo]]);export{qo as __pageData,xo as default};
