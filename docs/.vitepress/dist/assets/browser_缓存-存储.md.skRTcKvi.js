import{_ as r,D as d,o as l,c as n,k as o,I as c,w as a,a as e,R as s}from"./chunks/framework.4hIqoSk1.js";const i="/larry-book-vite/assets/07.OtB0ZLZr.png",D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"browser/缓存-存储.md","filePath":"browser/缓存-存储.md","lastUpdated":1733279472000}'),h={name:"browser/缓存-存储.md"},p=s('<h2 id="http-缓存划分" tabindex="-1">HTTP 缓存划分？ <a class="header-anchor" href="#http-缓存划分" aria-label="Permalink to &quot;HTTP 缓存划分？&quot;">​</a></h2><ol><li>按照 <strong>失效策略</strong> 划分为：</li></ol><ul><li>强缓存</li><li>协商缓存</li></ul><ol start="2"><li>按照 <strong>缓存位置</strong> 划分可以分为：</li></ol><ul><li>Service Worker Cache</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><ol start="3"><li>按照 <strong>存储型</strong> 划分为：</li></ol><ul><li>Cookie</li><li>Web Storage</li><li>IndexedDB 等</li></ul><h2 id="强缓存-和-协商缓存涉及到的-首部-头-字段有哪些" tabindex="-1">强缓存 和 协商缓存涉及到的 首部(头)字段有哪些? <a class="header-anchor" href="#强缓存-和-协商缓存涉及到的-首部-头-字段有哪些" aria-label="Permalink to &quot;强缓存 和 协商缓存涉及到的 首部(头)字段有哪些?&quot;">​</a></h2>',8),g=s("<blockquote><p>涉及首部字段为：<strong>Expires</strong> 和 <strong>Cache-Control</strong>。</p></blockquote><p><strong>Expires</strong></p><p><code>Expires</code> 首部字段是 <code>HTTP/1.0</code> 中定义缓存的字段，其给出了缓存过期的绝对时间，即在此时间之后，响应资源过期，属于实体首部字段。</p><p><strong>示例</strong>: <code>Expires: Wed, 11 May 2022 03:50:47 GMT</code></p><p>上述示例表示该资源将在以上时间之后过期，而在该时间之前浏览器可以直接从浏览器缓中读取数据，无需再次请求服务器。注意这里无需再次请求服务器便是<strong>命中了强缓存</strong>。</p><p>但是因为 <code>Expires</code> 设置的缓存过期时间是一个绝对时间，所以会受客户端时间的影响而变得不精准。</p><p><strong>Cache-control</strong><br><code>Cache-Control</code> 首部字段是 <code>HTTP/1.1</code> 中定义缓存的字段，其用于控制缓存的行为，可以组合使用多种指令，多个指令之间可以通过 “,” 分隔，属于通用首部字段。常用的指令有：<code>max-age</code>、<code>s-maxage</code>、<code>public/private</code>、<code>no-cache/no-store</code> 等。</p><p>如： <code>Cache-Control: max-age:3600 s-maxage=3600, public Cache-Control: no-cache</code></p><ul><li><strong>max-age</strong>: 指令给出了缓存过期的相对时间，单位为秒数。当其与 <code>Expires</code> 同时出现时，<code>max-age</code> 的优先级更高。但往往为了做向下兼容，两者都会经常出现在响应首部中。同时 <code>max-age</code> 还可在请求首部中被使用，告知服务器客户端希望接收一个存在时间（age）不大于多少秒的资源。</li><li><strong>s-max-age</strong>: 其只适用于公共缓存服务器，比如资源从源服务器发出后又被中间的代理服务器接收并缓存。当使用 <code>s-maxage</code> 指令后，公共缓存服务器将直接忽略 <code>Expires</code> 和 <code>max-age</code> 指令的值。</li><li><strong>publick</strong>: 指令表示该资源可以被任何节点缓存（包括客户端和代理服务器）。</li><li><strong>private</strong>: 表示该资源只提供给客户端缓存，代理服务器不会进行缓存。同时当设置了 <code>private</code> 指令后 <code>s-maxage</code> 指令将被忽略。</li><li><strong>no-store</strong>: 不进行任何缓存。</li><li><strong>no-cache</strong>: 在请求首部中被使用时，表示告知（代理）服务器不直接使用缓存，要求向源服务器发起请求，而当在响应首部中被返回时，表示客户端可以缓存资源，但每次使用缓存资源前都必须先向服务器确认其有效性，这对每次访问都需要确认身份的应用来说很有用。</li></ul>",9),_=s('<p><strong>协商缓存可以看作是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong></p><blockquote><p><strong>Last-Modified</strong> 和 <strong>If-Modified-Since</strong></p></blockquote><p><code>Last-Modified</code> 首部字段顾名思义，代表资源的最后修改时间，其属于响应首部字段。当浏览器第一次接收到服务器返回资源的 <code>Last-Modified</code> 值后，其会把这个值存储起来，并再下次访问该资源时通过携带 <code>If-Modified-Since</code> 请求首部发送给服务器验证该资源有没有过期。</p><p>示例:</p><p><code>Last-Modified: Fri , 14 May 2021 17:23:13 GMT</code><br><code>If-Modified-Since: Fri , 14 May 2021 17:23:13 GMT</code></p><p>如果在 <code>If-Modified-Since</code> 字段指定的时间之后资源发生了更新，那么服务器会将更新的资源发送给浏览器（状态码 200）并返回最新的 <code>Last-Modified</code> 值，浏览器收到资源后会更新缓存的 <code>If-Modified-Since</code> 的值。</p><p>如果在 <code>If-Modified-Since</code> 字段指定的时间之后资源都没有发生更新，那么服务器会返回状态码 <code>304 Not Modified</code> 的响应。</p><blockquote><p><strong>Etag</strong> 和 <strong>If-None-Match</strong></p></blockquote><p>示例</p><p><code>Etag: &quot;29322-09SpAhH3nXWd8KIVqB10hSSz66&quot;</code><br><code>If-None-Match: &quot;29322-09SpAhH3nXWd8KIVqB10hSSz66&quot;</code></p><p>如果服务器发现 <code>If-None-Match</code> 值与 <code>Etag</code> 不一致时，说明服务器上的文件已经被更新，那么服务器会发送更新后的资源给浏览器并返回最新的 <code>Etag</code> 值，浏览器收到资源后会更新缓存的 <code>If-None-Match</code> 的值。</p><h2 id="如何生成强缓存、命中强缓存" tabindex="-1">如何生成强缓存、命中强缓存？ <a class="header-anchor" href="#如何生成强缓存、命中强缓存" aria-label="Permalink to &quot;如何生成强缓存、命中强缓存？&quot;">​</a></h2><p><strong>生成过程：</strong></p><p>当浏览器发起 HTTP 请求时，会向浏览器缓存进行一次询问，若浏览器缓存没有该资源的缓存数据，那么浏览器便会向服务器发起请求，服务器接收请求后将资源返回给浏览器，浏览器会将资源的响应数据存储到浏览器缓存中，这便是<strong>强缓存的生成过程</strong></p><p><strong>命中过程：</strong></p><p>强缓存生成后，第二次访问该资源，就可以从缓存中拿到该资源，期间<strong>不需要与服务器交互</strong>。 会看到浏览器开发者工具中，资源的 <code>size</code>字段为 <code>Disk cache (磁盘缓存)</code> 或 <code>Memory Cache（内存缓存）</code> 这就是<strong>命中强缓存</strong>，其中 <strong>memory Cache</strong> 比 <strong>disk cache</strong> 更快，快到不需要时间。</p><p><img src="'+i+'" alt="命中强缓存"></p><blockquote><p><strong>注意：强缓存设置的 Expires(绝对日期) 和 max-age(相对时间) 都会收到客户端时间设置的影响</strong></p></blockquote><h2 id="如何生成协商缓存、命中协商缓存" tabindex="-1">如何生成协商缓存、命中协商缓存？ <a class="header-anchor" href="#如何生成协商缓存、命中协商缓存" aria-label="Permalink to &quot;如何生成协商缓存、命中协商缓存？&quot;">​</a></h2><p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。</strong></p><p>协商缓存可以基于两种头部来实现。</p><p><strong>第一种(基于修改时间)：</strong> 请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段实现，这两个字段的意思是：</p><p>响应头部中的 <code>Last-Modified</code>：标示这个响应资源的最后修改时间；</p><p>请求头部中的 <code>If-Modified-Since</code>：当资源过期了，发现响应头中具有 <code>Last-Modified</code> 声明，则再次发起请求的时候带上 <code>Last-Modified</code> 的时间，服务器收到请求后发现有 <code>If-Modified-Since</code> 则与被请求资源的最后修改时间进行对比（<code>Last-Modified</code>），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</p><p><strong>第二种(基于修改内容)：</strong> 请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段，这两个字段的意思是：</p><p>响应头部中 <code>Etag</code>：唯一标识响应资源；</p><p>请求头部中的 <code>If-None-Match</code>：当资源过期时，浏览器发现响应头里有 <code>Etag</code>，则再次向服务器发起请求时，会将请求头 <code>If-None-Match</code> 值设置为 <code>Etag</code> 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</p><blockquote><p><strong>注意：Etag 的优先级 要高于 Last-Modified, 协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</strong></p></blockquote><h2 id="谈谈你项目中是如何使用缓存的-缓存策略" tabindex="-1">谈谈你项目中是如何使用缓存的（缓存策略）？ <a class="header-anchor" href="#谈谈你项目中是如何使用缓存的-缓存策略" aria-label="Permalink to &quot;谈谈你项目中是如何使用缓存的（缓存策略）？&quot;">​</a></h2><p>现在项目都是 SPA 单页应用，在浏览器缓存层面上，使用<strong>强缓存</strong>和<strong>协商缓</strong>存配合使用。</p><ul><li><strong>频繁变动的资源，比如 HTML， 采用协商缓存。</strong></li><li><strong>CSS、JS、图片资源等采用强缓存，使用 hash 命名。</strong></li></ul><p>其中我们现在都使用 webpack、vite 等打包工具，在打包的时候会给资源文件名生成 hash。拿 webpack 举例：</p>',32),u=o("p",null,[o("code",null,"hash"),e(" 属于项目级别的 "),o("code",null,"hash"),e("，意思就是整个项目中只要有文件改变该 "),o("code",null,"hash"),e(" 值就会变化，同时所有文件也都共用该 "),o("code",null,"hash"),e(" 值。最终打包输出的资源文件名 "),o("code",null,"hash"),e(" 值都一样，按照缓存策略进行分析，浏览器加载所有资源都将重新请求服务器，导致没有改动资源的加载浪费，因此不建议在项目中采用这种方式进行构建。")],-1),f=o("p",null,[o("code",null,"chunkhash"),e(" 与 "),o("code",null,"hash"),e(" 不同，其属于入口文件级别的 "),o("code",null,"hash"),e("，会根据入口文件（entry）的依赖进行打包，同时为了避免一些公共库、插件被打包至入口文件中，我们可以借助 "),o("code",null,"CommonsChunkPlugin"),e(" 插件进行公共模块的提取。 "),o("strong",null,"公共模块一般除了升级版本外永远不会改动，我们希望浏览器能够将其存入强缓存中，不受其他业务模块的修改导致文件 chunkhash 名称变动的影响。")],-1),b=s('<p><code>contenthash</code> 是属于文件内容级别的 hash，其会根据文件内容的变化而变化。一般用于解决某个 js 中引用了其他资源 css，当 js 修改了会改变<code>chunkhash</code>, 同时 css 的 <code>chunkhash</code>也会被修改。所以这时候一般会把 css 的 hash 设置为 <code>contenthash</code>即可。</p><p><strong>总结：将 chunkhash 和 contenthash 组合使用才能最大化的利用 HTTP 缓存中强缓存的优势，减少不必要的资源重复请求，提升网页的整体打开速度。</strong></p><h2 id="cdn-是什么" tabindex="-1">CDN 是什么？ <a class="header-anchor" href="#cdn-是什么" aria-label="Permalink to &quot;CDN 是什么？&quot;">​</a></h2><h2 id="cookie、localstorage、sessionstorage-的区别" tabindex="-1">cookie、localStorage、sessionStorage 的区别？ <a class="header-anchor" href="#cookie、localstorage、sessionstorage-的区别" aria-label="Permalink to &quot;cookie、localStorage、sessionStorage 的区别？&quot;">​</a></h2><p>Cookie 的存储空间很小，不能超过 4KB，因此这一缺点也限制了它用于存储较大容量数据的能力。</p><h2 id="localhost-能否跨域共享" tabindex="-1">localhost 能否跨域共享？ <a class="header-anchor" href="#localhost-能否跨域共享" aria-label="Permalink to &quot;localhost 能否跨域共享？&quot;">​</a></h2>',6),k=o("a",{href:"https://a.test.com",target:"_blank",rel:"noreferrer"},"https://a.test.com",-1),m=o("a",{href:"https://b.test.com",target:"_blank",rel:"noreferrer"},"https://b.test.com",-1),T=o("a",{href:"https://a.test.com",target:"_blank",rel:"noreferrer"},"https://a.test.com",-1),S=o("a",{href:"https://test.com",target:"_blank",rel:"noreferrer"},"https://test.com",-1),M=o("ol",null,[o("li",null,"因为 localStorage 也有同源策略的限制，不能跨域。"),o("li",null,"子域名无法继承父域名的 localstorage，这点和 cookie 的差别很大。")],-1),C=o("blockquote",null,[o("p",null,'然而，如果这些域名拥有相同的顶级域名（比如都是 ".58.com"），浏览器将会认为它们是同一来源，因此它们之间的同源策略就不再适用。这样一来，不同子域名之间的页面就可以共享 localStorage 数据了。要实现这一点，你可以在DNS服务器设置中将不同的子域名都指向相同的顶级域名。通常，这是通过在 DNS 记录中配置 CNAME 记录或 A 记录来完成的。')],-1);function x(q,P,I,E,N,A){const t=d("font");return l(),n("div",null,[p,o("p",null,[o("strong",null,[c(t,{color:"blue"},{default:a(()=>[e("====强缓存====")]),_:1})])]),g,o("p",null,[o("strong",null,[c(t,{color:"blue"},{default:a(()=>[e("====协商缓存===")]),_:1})])]),_,o("p",null,[o("strong",null,[c(t,{color:"blue"},{default:a(()=>[e("1. hash")]),_:1})])]),u,o("p",null,[o("strong",null,[c(t,{color:"blue"},{default:a(()=>[e("2. chunkhash")]),_:1})])]),f,o("p",null,[o("strong",null,[c(t,{color:"blue"},{default:a(()=>[e("2. contenthash")]),_:1})])]),b,o("p",null,[k,e(" 和 "),m,e(),c(t,{color:"red"},{default:a(()=>[e("不能")]),_:1}),e("共享 localStorage？ "),T,e(" 和 "),S,e(),c(t,{color:"red"},{default:a(()=>[e("不能")]),_:1}),e("共享 localStorage？")]),M,C])}const L=r(h,[["render",x]]);export{D as __pageData,L as default};
