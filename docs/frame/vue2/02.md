::: tip
以下问题都是重点，能回答到什么程度，完全取决于，对 `Vue` 理解的深度。
:::

## 如何学习 Vue 源码？

::: details

1. **首先下载源码**

```bash
# [!code highlight] # 这个是克隆 Vue2.x 最新版本, 目前是2.7.x 以后也会是 2.7.x了不在重大更新了
git clone https://github.com/vuejs/vue.git
```

2. **装包**

```bash
# [!code highlight] # 装包, 最好使用 pnpm
pnpm install
```

3. **配置 source map**

```js
// [!code highlight] //在 package.json -> scripts 中的 dev 命令中添加 --sourcemap，这样就可以在浏览器中调试源码时查看当前代码在源码中的位置。
{
  "scripts": {
    "dev": "rollup -w -c scripts/config.js --sourcemap --environment TARGET:full-dev",
  }

}
```

4. **开发调试**

```bash
npm run dev
```

启动后 在`example` 目录中 创建 `test.html` 引入 `dist/vue.js` 即可 调试

```html
<body>
  <div id="app">{{ msg }}</div>

  <script src="../dist/vue.js"></script>
  <script>
    debugger
    const vm = new Vue({
      el: "#app",
      data: {
        msg: "hello init vue"
      }
    })
  </script>
</body>
```

:::

## Vue 的完整运行原理概览？

## Vue 初始化过程/原理（new Vue())?

::: details
总结核心就是做了 3 件事：

1. 合并选项，将 `Vue.options` 和传入的 `options` 进行合并。触发钩子(`beforeCreate`)
2. 初始化数据，并对数据进行响应式处理。触发钩子(`created`)
3. 编译代码，得到 `render` 函数，将 `vnode` 生成真实节点，并挂载到界面 (`beforeMount、mounted`)

> 源码位置：/src/core/instance/index.js(ts)

代码结构/流程上：

1. 原型方法属性：通过 5 个 `init` 方法，向 `Vue` 原型上添加。
2. 静态方法属性：在导入 `Vue` 构造函数的过程中，向 `Vue` 构造函数上添加静态方法
3. 实例化：在实例化的过程中，执行`_init` 方法，完成整个 `Vue` 初始化到渲染的逻辑。

**核心代码：**

```js
// [!code highlight] // Vue 构造函数
function Vue(options) {
  // [!code highlight] // 调用 Vue.prototype._init 方法，该方法是在 initMixin 中定义的
  this._init(options)
}

// [!code highlight] // 主要实现了 选项的合并，数据初始化（如响应式处理），以及触发编译和渲染的流程
initMixin(Vue)
// [!code highlight] // 主要实现了data,props的代理功能
stateMixin(Vue)
// [!code highlight] // 实现了 $on,$off,$once,$emit，用于监听，触发，销毁事件。
eventsMixin(Vue)
// [!code highlight] // 实现了三个方法：_update方法非常重要，它主要负责将vnode生成真实节点。
lifecycleMixin(Vue)
// [!code highlight] // 生成虚拟dom、实现$nextTick
renderMixin(Vue)
```

:::

## Vue 选项合并(mergeOptions)的策略是什么？

## 解释下 this.xxx 和 this.$data.xxx 和 this.\_data.xxx 为什么相等？

::: details

<font color="red">`this.$data`和`this._data`的关系</font>

首先说下，当我们访问 `$data` 时，实际访问的是`_data`（只不过`$data` 是只读的）

详细解答：在 `Vue` 初始化的时候，会在 `Vue.prototype` 上通过 `Object.defineProperty` 增加了 `$data` 属性，其中属性描述符中的，`get` 方法，返回的是` vue` 实例的 `_data` 属性，`set` 方法在非生产中是只读的。

> 源码位置：/src/core/instance/state.js(ts)

```ts
// [!code highlight] // 核心代码 在 stateMixin方法中
export function stateMixin(Vue: typeof Component) {
  // ...
  const dataDef: any = {}
  dataDef.get = function () {
    return this._data // [!code highlight] // 这里可以看到 返回的就是 _data
  }
  if (__DEV__) {
    dataDef.set = function () {
      warn(
        "Avoid replacing instance root $data. " +
          "Use nested data properties instead.",
        this
      )
    }
  }
  // [!code highlight] // $data 添加到了 vue原型上
  Object.defineProperty(Vue.prototype, "$data", dataDef)
  // ...
}
```

<font color="red">其次再来说 `this.xxx` 和 `this_data.xxx` 的关系</font>

核心就是 Vue 帮我们做了一层代理，当我们使用 `this.xxx` 访问 实例的某个属性时(data 选项下的属性), 其实最后访问的是 `this_data.xxx`。(应该这么说：代理 data 对象上的属性到 vm 实例，vm 实例是“代理商”)

> 源码位置：/src/core/instance/state.js(ts)

```ts
// [!code highlight] // 核心代码 在 initData方法中
function initData(vm: Component) {
  // 得到 data 对象
  let data: any = vm.$options.data
  data = vm._data = isFunction(data) ? getData(data, vm) : data || {}
  // ...
  // proxy data on instance
  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    // ...
    // [!code highlight] 遍历所有的key，调用代理方法，代理到vm实例上
    proxy(vm, `_data`, key)
  }
  // ...
}

// [!code highlight] // 属性描述
const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

// [!code highlight] // 核心代理方法
export function proxy(target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key] // [!code highlight] // this._data.xxx
  }
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val // [!code highlight] // this._data.xxx = val
  }
  // [!code highlight] // 最后访问的 this(vm).xxx 其实就是在访问 this._data.xxx, 同理 set赋值 也是如此
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

:::

## 为什么访问 data 里的 属性，不需要带 data？

::: details
核心原理同上(把`data`里的属性访问、赋值代理到了`vue`实例上)。并且最后的`vue`(组件)实例上压根就没有 `data`属性，有`$data` 和 `_data`
:::

## methods 里面的 this 为什么会指向 Vue 实例？

::: details
核心使用的是原生的 `bind` 方法 来实现 `this` 的执行环境

> 源码位置: /src/core/instance/state.js(ts)

```js
// initState 方法中 如果存在 methods选项 调用 initMethods方法
export function initState(vm: Component) {
  const opts = vm.$options
  // ...
  if (opts.methods) initMethods(vm, opts.methods)
  // ...
}

function initMethods(vm: Component, methods: Object) {
  for (const key in methods) {
    // ...
    // [!code highlight] bind(methods[key], vm)
    vm[key] = typeof methods[key] !== "function" ? noop : bind(methods[key], vm)
  }
}
```

> bind 方法源码位置：/src/shared/util.ts

```js
// [!code highlight] // 可以看到 核心就是 原生的 bind 方法！！！
function nativeBind(fn: Function, ctx: Object): Function {
  return fn.bind(ctx)
}

// @ts-expect-error bind cannot be `undefined`
export const bind = Function.prototype.bind ? nativeBind : polyfillBind
```

:::

## Vue 的响应式原理？

## 什么是数据劫持，Vue 是如何做？（响应式拆分细节问题）

## 如何防止对某个属性重复进行劫持？（响应式拆分细节问题）

## 什么是依赖收集？（响应式拆分细节问题）

## Vue 怎么实现依赖收集的？（响应式拆分细节问题）

## Vue 如何依赖回调/派发更新的？（响应式拆分细节问题）

## Vue 双向数据绑定原理(和响应式原理到底是不是一个问题)？

## 虚拟 DOM 是什么？

## 虚拟 DOM 一定比真实 DOM 快吗？

## 谈谈 Vue 的 Diff（path）算法？

## Vue 的模板编译原理？

## computed 缓存的原理？

## nextTick 的使用和原理

## vue 的数据为什么频繁变化但只会更新一次？

::: details
这是因为 vue 的 DOM 更新是一个异步操作，在数据更新后会首先被 set 钩子监听到，但是不会马上执行 DOM 更新，而是在下一轮循环中执行更新。
具体实现是 vue 中实现了一个 queue 队列用于存放本次事件循环中的所有 watcher 更新，并且同一个 watcher 的更新只会被推入队列一次，并在本轮事件循环的微任务执行结束后执行此更新(UI Render 阶段)，这就是 DOM 只会更新一次的原因。
这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，vue 刷新队列并执行实际 (已去重的) 工作。vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。
:::

## Vue.set 的原理？

## Vue.delete 的原理?

## Vue.use 的原理？

## Vue.mixin 的原理？

## Vue.extends 的原理？

## keep-alive 实现原理？

## vue 单文件组件中，样式 scoped 实现原理？

## Vuex 的实现原理？

## 你有对 Vue 项目进行哪些优化？
