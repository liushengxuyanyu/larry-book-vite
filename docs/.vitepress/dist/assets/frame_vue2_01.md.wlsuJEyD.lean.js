import{_ as t,D as p,o as h,c as k,k as s,I as n,w as l,a as i,R as e}from"./chunks/framework.CP3Xps-Z.js";const G=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frame/vue2/01.md","filePath":"frame/vue2/01.md","lastUpdated":1702988788000}'),r={name:"frame/vue2/01.md"},d=e("",13),c={class:"details custom-block"},o=s("summary",null,"查看答案",-1),E=e("",1),u=s("ol",null,[s("li",null,"通过共有父组件进行中转(不推荐)")],-1),g=s("ol",null,[s("li",null,[s("code",null,"$root"),i(" 可以直接访问"),s("strong",null,"根组件实例")]),s("li",null,[s("strong",null,"祖先组件"),i("使用 "),s("code",null,"provide"),i(", 提供一个值，可以被"),s("strong",null,[i("后代组件使用"),s("code",null,"inject"),i("进行注入")])])],-1),y=e("",1),b=e("",9),m={class:"details custom-block"},F=e("",2),v=s("blockquote",null,[s("p",null,[s("strong",null,"如果在一次渲染中，有多个地方使用了同一个 methods 或 computed 属性，methods 会被执行多次，而 computed 的回调函数则只会被执行一次。")])],-1),C=s("blockquote",null,[s("p",null,[s("strong",null,"computed 和 watch 的本质是一样的，当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])],-1),D=e("",34),B={class:"details custom-block"},A=s("summary",null,"查看答案",-1),f=s("code",null,"vue.js",-1),_=s("code",null,"UMD",-1),q=s("strong",null,"全量包",-1),V=s("code",null,"template",-1),w=s("code",null,"html",-1),x=s("code",null,"vue.runtime.js",-1),j=s("code",null,"Vue",-1),S=s("code",null,"patch",-1),P=s("code",null,"webpack",-1),T=s("code",null,"vue",-1),M=s("code",null,"vue-loader",-1),$=s("code",null,"*.vue",-1),I=s("code",null,"JavaScript",-1),O=e("",2);function L(N,J,H,R,z,W){const a=p("font");return h(),k("div",null,[d,s("details",c,[o,s("ul",null,[s("li",null,[s("p",null,[s("strong",null,[n(a,{style:{color:"red"}},{default:l(()=>[i("父子组件通信:")]),_:1})])]),E]),s("li",null,[s("p",null,[s("strong",null,[n(a,{style:{color:"red"}},{default:l(()=>[i("兄弟组件通信:")]),_:1})])]),u]),s("li",null,[s("p",null,[s("strong",null,[n(a,{style:{color:"red"}},{default:l(()=>[i("跨层级组件通信：")]),_:1})])]),g]),s("li",null,[s("p",null,[s("strong",null,[n(a,{style:{color:"red"}},{default:l(()=>[i("通用通信：")]),_:1})])]),y])])]),b,s("details",m,[F,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("methods VS computed")]),_:1})])]),v,s("p",null,[s("strong",null,[n(a,{color:"red"},{default:l(()=>[i("computed VS watch")]),_:1})])]),C]),D,s("details",B,[A,s("ul",null,[s("li",null,[s("p",null,[f,i(" 是基于 "),_,i(" 的一个"),q,i("，包含"),n(a,{color:"red"},{default:l(()=>[i("编译器（compiler）")]),_:1}),i(" 和 "),n(a,{color:"red"},{default:l(()=>[i("运行时（runtime）")]),_:1}),i("。如果你需要动态编译模版（比如：将字符串模版传递给 "),V,i(" 选项，或者通过提供一个挂载元素的方式编写 "),w,i(" 模版），你将需要编译器，因此需要一个完整的构建包。")])]),s("li",null,[s("p",null,[x,i(" 是"),n(a,{color:"red"},{default:l(()=>[i("运行时包")]),_:1}),i("，负责创建 "),j,i(" 实例、渲染函数、"),S,i(" 虚拟 DOM 等代码，基本上除了编译器之外的代码都属于运行时代码。我们大部分是在基于构建工具如 "),P,i(" 中开发 "),T,i("应用, 可以使用 "),M,i(" 负责把 "),$,i(" 文件中的模版在构建时会被编译为 "),I,i(" 的渲染函数, 因此你不需要包含编译器的全量包，只需使用只包含运行时的包即可。")])])])]),O])}const K=t(r,[["render",L]]);export{G as __pageData,K as default};
