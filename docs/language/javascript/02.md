
## script标签中的 defer 和 async 的区别？
::: details

- **defer并行加载js文件，会按照页面上script标签的顺序执行**
- **async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行**

**defer**

- `defer` 延迟属性可以使浏览器不需要等待脚本的下载，浏览器会继续处理 html 构建 DOM，直到完全构建完 DOM 后才会执行脚本。就是总是在 DOM 构建完之后才会执行，在 `DOMContentLoaded` 事件之前执行。

- `defer` 脚本保持相对顺序来执行，就像常规脚本一样。多个 `defer` 脚本会并行下载，但执行的时候会按照顺序执行。

- `webpack` 打包后 `htmlWabpackPlugin` 会默认生成为 `defer` 脚本引入 `bundle。`

**async**

- `async` 异步加载脚本，不会阻塞页面渲染。
- `DOMContentLoaded` 可能发生在 `async` **之前** 或 **之后**
- `async` 加载脚本完脚本会立即执行，可以在 `DOM` 尚未完全下载完成就加载和执行。
- 一般将没有依赖的独立的第三方脚本设置成 `async`

:::

## 常见的异步解决方案有哪些？
::: details
**<font color="red">1. 回调函数</font>**
```js
function fetchData(callback) {
  setTimeout(() => {
    const data = 'Hello, world!';
    callback(data);
  }, 1000);
}

fetchData((data) => {
  console.log(data); // 输出：Hello, world!
});
 
```
**<font color="red">2. 事件监听(发布/订阅)</font>**
```js
function fetchData() {
  setTimeout(() => {
    const data = 'Hello, world!';
    messageCenter.publish('dataReceived', data);
  }, 1000);
}

messageCenter.subscribe('dataReceived', (data) => {
  console.log(data); // 输出：Hello, world!
});

fetchData();
```
**<font color="red">3. promise</font>**
```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = 'Hello, world!';
      resolve(data);
    }, 1000);
  });
}

fetchData()
.then((data) => {
  console.log(data); // 输出：Hello, world!
})
.catch((error) => {
  console.error(error);
});
```
**<font color="red">4. Generator函数</font>**
```js
function* fetchData() {
  try {
    const data = yield new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('Hello, world!');
      }, 1000);
    });
    console.log(data); // 输出：Hello, world!
  } catch (error) {
    console.error(error);
  }
}

const generator = fetchData();
const promise = generator.next().value;
promise
  .then((data) => {
    generator.next(data);
  })
  .catch((error) => {
    generator.throw(error);
  });
 
```
**<font color="red">5. async</font>**
```js
async function fetchData() {
  try {
    const data = await new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('Hello, world!');
      }, 1000);
    });
    console.log(data); // 输出：Hello, world!
  } catch (error) {
    console.error(error);
  }
}

fetchData();
```

:::

## jS为什么要区分微任务和宏任务？


<style>
  /* 这里是 details 块的样式重写  不要切换黑暗模式 */
  /* .custom-block {
    padding: 0 !important;
    font-size: 16px;
  } */
  .custom-block.details {
    background-color: #fff !important;
    padding: 0 !important;
    font-size: 16px;
  }
  .custom-block.details summary {
    color: #3451b2 !important;
  }
</style>