## MVC、MVVM 的区别？

::: details

- `MVC：` 前端的 MVC 与后端类似，具备着 View、Controller 和 Model。

  - `Model：`负责保存应用数据，与后端数据进行同步。

  - `Controller：`负责业务逻辑，根据用户行为对 Model 数据进行修改。

  - `View：`负责视图展示，将 Model 中的数据可视化出来。

> 早期的`backbone.js`框架就是这种`MVC`的模式。

- `MVVM：` MVVM 可以分解成(`Model-View-VIewModel`)。ViewModel 可以理解为在 presenter 基础上的进阶版

  - `Model：`模型层（数据层），主要用于保存一些数据

  - `View：` 视图层，主要用于将后端数据借助各种元素呈现给用户，同时也可提供用户操作的入口

  - `ViewModel：`视图模型层：该层也是 mvvm 中的核心层，主要用于作为 Model 个 View 两个层的数据连接层，负责两个层之间的数据传递。该层主要包含两大功能点：

    - `DOM监听`（DOM Listener） 用于监听 dom 元素的一些事件，如果 dom 元素发生变化在需要的时候会改变对应的 data

    - `数据绑定`（Data bindings）用于将 model 的改变反应在 view 上及时呈现给用户

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作是由 Vue.js 完成的，我们不需要手动操作 DOM，只需要维护好数据状态。
:::

## Vue 概述？

::: details
`Vue` 是一款用于构建用户界面的 `JavaScript` 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型。

- `声明式渲染：`Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。

- `响应式：` Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM。

- `渐进式框架：` Vue 是一个框架，也是一个生态。

  - 无需构建步骤，渐进式增强静态的 HTML
  - 在任何页面中作为 Web Components 嵌入
  - 单页应用 (SPA)
  - 全栈 / 服务端渲染 (SSR)
  - Jamstack / 静态站点生成 (SSG)
  - 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面

- `单文件组件：` 在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 \*.vue 文件，英文 Single-File Components，缩写为 SFC)。

- `选项式API/组合式API`
  :::

## 谈谈你对 SPA 单页面的理解？

::: details
**SPA（ single-page application ）**仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势
  :::

## 为什么 data 是个函数并且返回一个对象呢？

::: details
`data` 之所以是一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行`data`函数并返回新的数据对象，这样，可以避免多处调用之间的数据污染。
:::

## 举例常用的 Vue 修饰符？

::: details

1. **trim**

`trim`修饰符的作用类似于`JavaScript`中的`trim()`方法，作用是把`v-model`绑定的值的首尾空格给过滤掉。

```html
<input type="text" v-model.trim="value" />
```

2. **lazy**

`lazy`修饰符作用是，改变输入框的值时`value`不会改变，当光标离开输入框时，`v-model`绑定的值`value`才会改变

```html
<input type="text" v-model.lazy="value" />
```

3. **number**

`number`修饰符的作用是将值转成数字，但是先输入字符串和先输入数字，是两种情况

```html
<!-- 先输入数字，在输入字符串会截取数字部分。 先输入字符串的话 修饰符无效 -->
<input type="text" v-model.number="value" />
```

4. **stop**

`stope`修饰符的作用是**阻止冒泡**

```js
<div @click="clickEvent(2)">
    <button @click.stop="clickEvent(1)">点击</button>
</div>

methods: {
  clickEvent(num) {
    // 不加 stop 点击按钮输出 1 2
    // 加了 stop 点击按钮输出 1
    console.log(num)
  }
}
```

5. **capture**

`capture` 由外网内**捕获**, 在被内部元素处理前，先被外部处理

```js
<div @click.capture="clickEvent(2)">
    <button @click="clickEvent(1)">点击</button>
</div>

methods: {
  clickEvent(num) {
    // 不加 capture 点击按钮输出 1 2
    // 加了 capture 点击按钮输出 2 1
    console.log(num)
  }
}
```

6. **self**

`self`修饰符作用是，只有点击事件绑定的本身才会触发事件

```js
<div @click.self="clickEvent(2)">
  <button @click="clickEvent(1)">点击</button>
</div>

methods: {
  clickEvent(num) {
    // 不加 self 点击按钮输出 1 2
    // 加了 self 点击按钮输出 1 点击div不分 才会输出 2
    console.log(num)
  }
}
```

7. **once**

`once`修饰符的作用是，事件只执行一次

```js
<button @click="clickEvent(1)">点击</button>

methods: {
  clickEvent(num) {
    // 不加 once 多次点击按钮输出 1
    // 加了 once 多次点击按钮只会输出一次 1
    console.log(num)
  }
}
```

8. **prevent**

`prevent`修饰符的作用是阻止默认事件（例如 a 标签的跳转）

```js
<a href="#" @click.prevent="clickEvent(1)">点我</a>

methods: {
  clickEvent(num) {
    // 不加 prevent 点击a标签 先跳转然后输出 1
    // 加了 prevent 点击a标签 不会跳转只会输出 1
    console.log(num)
  }
}

```

9. **native**

`native`修饰符是加在自定义组件的事件上，保证事件能执行

```html
<!-- 执行不了 -->
<My-component @click="clickEvent(3)"></My-component>

<!-- 可以执行 -->
<My-component @click.native="clickEvent(3)"></My-component>
```

10. **sync**

当**父组件**传值进**子组件**，子组件想要改变这个值时，可以这么做

```js
// <!-- 父组件里 -->
<children :foo="bar" @update:foo="val => bar = val"></children>

// <!-- 子组件里 -->
this.$emit('update:foo', newValue)
```

使用 `sync` 后可以简化

```js
// 父组件里
<children :foo.sync="bar"></children>

// 子组件里
this.$emit('update:foo', newValue)
```

:::

## 举例 Vue 常用的指令？

::: details

- `v-text`: 更新元素的 `textContent`
- `v-html`: 更新元素的 `innerHTML`
- `v-show`: 根据表达式的布尔值，切换元素的 `css display` 效果
- `v-if`: 根据表达式的布尔值，组件将被**销毁/重建**
- `v-else`: 前一个元素必须有`v-if` 或 `v-else-if`
- `v-else-if`: 前一个元素必须有`v-if` 或 `v-else-if`
- `v-for`: 列表渲染, 数组、对象、字符串、数字都可以
- `v-on`: 绑定事件, 简写 `@on`
- `v-bind`: 绑定变量，简写 `:`
- `v-model`: 双向数据绑定表单项的值
- `v-slot`: 具名插槽名字，简写 `#`
- `v-pre`: 跳过该元素及其所有子元素的编译。(写文档的时候可以用到，CRUD 那个 Doc 用的就是 v-pre 实现的.)
- `v-once`: 元素、组件只渲染一次，并跳过之后的更新。
- `v-memo`: 3.2+后加入的，用于缓存的，[参考官网](https://cn.vuejs.org/api/built-in-directives.html#v-memo)
- `v-cloak`: 用于隐藏尚未完成编译的 DOM 模板。

:::

## Vue 组件之间通信方式有哪些？

::: details

- **父子组件通信:**

  1. 父组件 通过子组件定义的 `props`传递给 子组件，子组件通过 `$emit()` 触发父组件中 **自定义事件** 进行回传
  2. 父组件 `$refs` 获取 子组件实例, 然后调用 子组件 内的 属性、方法等
  3. 子组件通过 `$parent` 获取父组件实例。
  4. 父组件 通过 `$attrs`、`$listeners`, 是指由父组件传入，且没有被子组件声明为 `props` 或是组件自定义事件的 `attributes` 和事件处理函数。一般组件进行二次封装时可以方便传值。

- **兄弟组件通信:**

  1. 通过共有父组件进行中转(不推荐)

- **跨层级组件通信：**

  1. `$root` 可以直接访问**根组件实例**
  2. **祖先组件**使用 `provide`, 提供一个值，可以被**后代组件使用`inject`进行注入**

- **通用通信：**
  1. 全局状态管理`Vuex(vue2推荐)`、`Pinia(vue3推荐)`
  2. 使用`eventbus`事件总线，`$on`进行事件监听，`$emit` 进行事件触发，从而通信.
  3. `WebStorage`、`Cookie`等 (无法响应式，根据情况而定)

:::

## Vue2 的生命周期?

::: details

1. **beforeCreated**:

实例了`vue`，但还没有进行数据初始化 和 响应式处理

2. **created**:

`vue`实例创建后同步调用，在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：`数据侦听`、`计算属性`、`方法`、`事件/侦听器`的回调函数。然而，挂载阶段还没开始，且 `$el property` 目前尚不可用。

3. **beforeMount**:

`render`函数在这里会被调用，生成`虚拟DOM`, 但是还没有生成真正的`DOM`并替换到`el`上

4. **mounted**:

在这个阶段真实的`DOM`挂载完毕，可以获取到`DOM`。 注意 `mounted` 不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 `mounted` 内部使用 `vm.$nextTick`

5. **beforeUpdate**:

数据更新后，新的`虚拟DOM`生成，但还没有和`旧的虚拟DOM`做对比.

6. **update**:

`新旧虚拟DOM`对比后，进行`真实DOM`更新，注意，`updated` 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 `vm.$nextTick`

7. **activated**:

被`keep-alive`缓存组件激活时调用

8. **deactivated**:

被`keep-alive`缓存组件停用时调用

9. **beforeDestroy**:

组件实例销毁之前调用，在这里依然能够获取到数据。

10. **destroyed**:

组件实例销毁后调用，对应的所有指令、事件将会被解绑，所有子组件实例也会被销毁

11. **errorCaptured(2.5.0+ 新增)**:

在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

:::
