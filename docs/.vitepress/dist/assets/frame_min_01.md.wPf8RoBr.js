import{_ as i,o,c as l,k as a,t,R as e}from"./chunks/framework.4hIqoSk1.js";const q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"frame/min/01.md","filePath":"frame/min/01.md","lastUpdated":1733279472000}'),n={name:"frame/min/01.md"},r=e('<h2 id="小程序原理和架构" tabindex="-1">小程序原理和架构 ？ <a class="header-anchor" href="#小程序原理和架构" aria-label="Permalink to &quot;小程序原理和架构 ？&quot;">​</a></h2><h2 id="小程序有几种文件" tabindex="-1">小程序有几种文件？ <a class="header-anchor" href="#小程序有几种文件" aria-label="Permalink to &quot;小程序有几种文件？&quot;">​</a></h2><ul><li><p>WXML： 微信自己定义的一套组件</p></li><li><p>WXSS : 用于描述 WXML 的组件样式</p></li><li><p>js : 逻辑处理</p></li><li><p>json : 小程序页面配置（如页面注册，页面标题及tabBar）</p></li><li><p>wxs： 封装模块的</p></li></ul><h2 id="小程序的-wxss-和-css-有什么区别" tabindex="-1">小程序的 wxss 和 css 有什么区别？ <a class="header-anchor" href="#小程序的-wxss-和-css-有什么区别" aria-label="Permalink to &quot;小程序的 wxss 和 css 有什么区别？&quot;">​</a></h2><ul><li>1：WXSS具有CSS大部分的特性，也做了一些扩充和修改</li><li>2：WXSS新增了尺寸单位，WXSS在底层支持新的尺寸单位rpx</li><li>3：WXSS仅支持部分CSS选择器</li><li>4：WXSS提供全局样式与局部样式</li><li>5：WXSS背景图片只能引入外链，不能使用本地图片</li><li>6：小程序样式使用 @import 引入 外联样式文件，地址为相对路径。</li><li>7：尺寸单位为 rpx , rpx 是响应式像素,可以根据屏幕宽度进行自适应。</li></ul><h2 id="小程序wxml与标准的html的异同" tabindex="-1">小程序wxml与标准的html的异同？ <a class="header-anchor" href="#小程序wxml与标准的html的异同" aria-label="Permalink to &quot;小程序wxml与标准的html的异同？&quot;">​</a></h2>',6),d=a("li",null,"标签名字不一样，且小程序标签更少，单一标签更多；view，text，image，navigator",-1),s=a("li",null,"WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器内预览；",-1),c=a("li",null,"组件封装不同， WXML对组件进行了重新封装，",-1),h=a("li",null,"小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。",-1),p=e(`<h2 id="小程序的样式尺寸单位是什么" tabindex="-1">小程序的样式尺寸单位是什么？ <a class="header-anchor" href="#小程序的样式尺寸单位是什么" aria-label="Permalink to &quot;小程序的样式尺寸单位是什么？&quot;">​</a></h2><p>是 <code>rpx</code></p><h2 id="小程序app-json-全局配置文件描述" tabindex="-1">小程序app.json 全局配置文件描述 ？ <a class="header-anchor" href="#小程序app-json-全局配置文件描述" aria-label="Permalink to &quot;小程序app.json 全局配置文件描述 ？&quot;">​</a></h2><ul><li>pages : 用于存放当前小程序的所有页面路径</li><li>window : 小程序所有页面的顶部背景颜色，文字颜色配置。</li><li>tabBar : 小程序底部的 Tab ,最多5个，最少2个</li></ul><h2 id="小程序的双向绑定" tabindex="-1">小程序的双向绑定？ <a class="header-anchor" href="#小程序的双向绑定" aria-label="Permalink to &quot;小程序的双向绑定？&quot;">​</a></h2><p>小程序直接 <code>this.data</code>属性是不可以同步到视图的，必须调用</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这里设置</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="什么是冷启动-和-热启动" tabindex="-1">什么是冷启动 和 热启动？ <a class="header-anchor" href="#什么是冷启动-和-热启动" aria-label="Permalink to &quot;什么是冷启动 和 热启动？&quot;">​</a></h2><p>小程序启动可以分为两种情况，一种是冷启动，一种是热启动</p><ul><li>冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动</li><li>热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态</li></ul><h2 id="小程序的生命周期" tabindex="-1">小程序的生命周期? <a class="header-anchor" href="#小程序的生命周期" aria-label="Permalink to &quot;小程序的生命周期?&quot;">​</a></h2><p>相关面试题：<a href="https://blog.csdn.net/qq_63358859/article/details/136258427" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_63358859/article/details/136258427</a></p><p><strong>1. 应用级别生命周期</strong></p><p>应用生命周期通常是指一个小程序从 启动 → 运行 → 销毁的整个过程，，应用生命周期函数需要 在 <code>app.js</code> 文件的 <code>App()</code> 方法中定义</p><ul><li><code>onLaunch</code>: 监听小程序初始化，全局只会执行 1 次。</li><li><code>onShow</code>: 监听小程序启动或切前台</li><li><code>onHide</code>: 监听小程序切后台</li></ul><p><strong>2. 页面级别生命周期</strong></p><p>页面生命周期就是指小程序页面从 加载 → 运行 → 销毁的整个过程，小程序中的一个页面都需要在对应页面的 <code>.js</code> 文件中调用 <code>Page()</code> 方法来注册。<code>Page()</code> 接受一个 <code>Object</code> 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。</p><ul><li><code>onLoad</code>: 页面加载时触发。一个页面只会调用一次，可以在<code>onLoad</code> 的参数中获取打开当前页面路径中的参数</li><li><code>onShow</code>: 页面显示/切入前台时触发</li><li><code>onReady</code>: 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互</li><li><code>onHide</code>: 页面隐藏/切入后台时触发。 如 <code>navigateTo</code> 或底部 <code>tab</code> 切换到其他页面，小程序切入后台等</li><li><code>onUnload</code>: 页面卸载时触发。如 <code>redirectTo</code> 或 <code>navigateBack</code> 到其他页面时</li></ul><blockquote><p>注意触发顺序是： onLoad -&gt; onShow -&gt; onReady</p></blockquote><h2 id="小程序页面间有哪些传递数据的方法" tabindex="-1">小程序页面间有哪些传递数据的方法？ <a class="header-anchor" href="#小程序页面间有哪些传递数据的方法" aria-label="Permalink to &quot;小程序页面间有哪些传递数据的方法？&quot;">​</a></h2><ol><li>使用全局变量实现数据传递。在 app.js 文件中定义全局变量 globalData， 将需要存储的信息存放在里面</li><li>使用 wx.navigateTo与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面onLoad的时候初始化</li><li>使用本地缓存Storage 相关</li></ol><h2 id="小程序怎么跟随事件传值" tabindex="-1">小程序怎么跟随事件传值？ <a class="header-anchor" href="#小程序怎么跟随事件传值" aria-label="Permalink to &quot;小程序怎么跟随事件传值？&quot;">​</a></h2><p>给 HTML 元素添加 <code>data-*</code> 属性来传递我们需要的值，然后通过 <code>e.currentTarget.dataset</code> 或 <code>onload</code>的 <code>param</code>参数获取。但 <code>data-</code>名称不能有大写字母和不可以存放对象</p><h2 id="简述下-wx-navigateto-wx-redirectto-wx-switchtab-wx-navigateback-wx-relaunch-的区别" tabindex="-1">简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别? <a class="header-anchor" href="#简述下-wx-navigateto-wx-redirectto-wx-switchtab-wx-navigateback-wx-relaunch-的区别" aria-label="Permalink to &quot;简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?&quot;">​</a></h2><ul><li>wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面</li><li>wx.redirectTo()：关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面</li><li>wx.switchTab()：跳转到 abBar 页面，并关闭其他所有非 tabBar 页面</li><li>wx.navigateBack()：关闭当前页面，返回上一页面或多级页面。可通过getCurrentPages() 获取当前的页面栈，决定需要返回几层</li><li>wx.reLaunch()：关闭所有页面，打开到应用内的某个页面</li></ul><h2 id="小程序主包大小限制" tabindex="-1">小程序主包大小限制？ <a class="header-anchor" href="#小程序主包大小限制" aria-label="Permalink to &quot;小程序主包大小限制？&quot;">​</a></h2><h2 id="小程序怎么分包" tabindex="-1">小程序怎么分包？ <a class="header-anchor" href="#小程序怎么分包" aria-label="Permalink to &quot;小程序怎么分包？&quot;">​</a></h2><h2 id="小程序如何自定义tabbar" tabindex="-1">小程序如何自定义tabbar？ <a class="header-anchor" href="#小程序如何自定义tabbar" aria-label="Permalink to &quot;小程序如何自定义tabbar？&quot;">​</a></h2><h2 id="bindtap和catchtap的区别是什么" tabindex="-1">bindtap和catchtap的区别是什么？ <a class="header-anchor" href="#bindtap和catchtap的区别是什么" aria-label="Permalink to &quot;bindtap和catchtap的区别是什么？&quot;">​</a></h2><p>相同： 首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分</p><p>不同： 他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的</p><h2 id="小程序中的openid-和-unionid的区别" tabindex="-1">小程序中的openId 和 unionId的区别？ <a class="header-anchor" href="#小程序中的openid-和-unionid的区别" aria-label="Permalink to &quot;小程序中的openId 和 unionId的区别？&quot;">​</a></h2><p><strong>OpenId</strong>：OpenId 是一个用户对于一个小程序／公众号的标识, 用于识别用户身份、安全验证等</p><ul><li>同一个人，使用不同的小程序，会留下不同的小程序 OpenId</li><li>同一个微信用户在小程序和公众号上的openid是不同的</li></ul><p><strong>UnionId</strong>: UnionId 是一个用户对于同主体微信小程序／公众号／APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过 UnionId，实现多个小程序、公众号、甚至APP 之间的数据互通。</p><ul><li>同一用户，对同一个微信开放平台下的不同应用，unionid是相同的</li></ul><p>开发者可以直接通过 wx.login + code2Session 获取到该用户 UnionID，无须用户授权。</p><h2 id="小程序的登陆流程" tabindex="-1">小程序的登陆流程？ <a class="header-anchor" href="#小程序的登陆流程" aria-label="Permalink to &quot;小程序的登陆流程？&quot;">​</a></h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html" target="_blank" rel="noreferrer">https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html</a></p><ol><li>调用 <code>wx.login()</code> 获取 临时登录凭证<code>code</code> ，并回传到开发者服务器。</li><li>开发者服务器调用 auth.code2Session 接口，换取 用户唯一标识 <code>OpenID</code> 、 用户在微信开放平台账号下的唯一标识<code>UnionID</code>（若当前小程序已绑定到微信开放平台账号） 和 会话密钥 <code>session_key</code></li></ol><h2 id="小程序的本地存储-如果切换用户后-能访问到之前的本地存储吗" tabindex="-1">小程序的本地存储，如果切换用户后，能访问到之前的本地存储吗？ <a class="header-anchor" href="#小程序的本地存储-如果切换用户后-能访问到之前的本地存储吗" aria-label="Permalink to &quot;小程序的本地存储，如果切换用户后，能访问到之前的本地存储吗？&quot;">​</a></h2><p><strong>不能</strong>， 小程序的本地缓存不仅仅通过小程序这个维度来隔离空间，还会考虑不同用户的情况。</p><h2 id="小程序中常见的开放能力api" tabindex="-1">小程序中常见的开放能力API <a class="header-anchor" href="#小程序中常见的开放能力api" aria-label="Permalink to &quot;小程序中常见的开放能力API&quot;">​</a></h2><ul><li>分享</li><li>扫码</li></ul>`,44);function u(b,x,m,g,w,k){return o(),l("div",null,[r,a("ul",null,[d,a("li",null,"多了一些wx:if 这样的属性以及 "+t()+"这样的表达式",1),s,c,h]),p])}const f=i(n,[["render",u]]);export{q as __pageData,f as default};
